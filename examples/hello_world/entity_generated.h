// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ENTITY_H_
#define FLATBUFFERS_GENERATED_ENTITY_H_

#include "flatbuffers/flatbuffers.h"

#include "lullaby/generated/common_generated.h"
#include "lullaby/generated/render_def_generated.h"
#include "lullaby/generated/text_def_generated.h"
#include "lullaby/generated/transform_def_generated.h"

struct ComponentDef;

struct EntityDef;

enum ComponentDefType {
  ComponentDefType_NONE = 0,
  ComponentDefType_RenderDef = 1,
  ComponentDefType_TextDef = 2,
  ComponentDefType_TransformDef = 3,
  ComponentDefType_MIN = ComponentDefType_NONE,
  ComponentDefType_MAX = ComponentDefType_TransformDef
};

inline ComponentDefType (&EnumValuesComponentDefType())[4] {
  static ComponentDefType values[] = {
    ComponentDefType_NONE,
    ComponentDefType_RenderDef,
    ComponentDefType_TextDef,
    ComponentDefType_TransformDef
  };
  return values;
}

inline const char **EnumNamesComponentDefType() {
  static const char *names[] = {
    "NONE",
    "RenderDef",
    "TextDef",
    "TransformDef",
    nullptr
  };
  return names;
}

inline const char *EnumNameComponentDefType(ComponentDefType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesComponentDefType()[index];
}

template<typename T> struct ComponentDefTypeTraits {
  static const ComponentDefType enum_value = ComponentDefType_NONE;
};

template<> struct ComponentDefTypeTraits<lull::RenderDef> {
  static const ComponentDefType enum_value = ComponentDefType_RenderDef;
};

template<> struct ComponentDefTypeTraits<lull::TextDef> {
  static const ComponentDefType enum_value = ComponentDefType_TextDef;
};

template<> struct ComponentDefTypeTraits<lull::TransformDef> {
  static const ComponentDefType enum_value = ComponentDefType_TransformDef;
};

bool VerifyComponentDefType(flatbuffers::Verifier &verifier, const void *obj, ComponentDefType type);
bool VerifyComponentDefTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct ComponentDef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ComponentDef";
  }
  enum {
    VT_DEF_TYPE = 4,
    VT_DEF = 6
  };
  ComponentDefType def_type() const {
    return static_cast<ComponentDefType>(GetField<uint8_t>(VT_DEF_TYPE, 0));
  }
  const void *def() const {
    return GetPointer<const void *>(VT_DEF);
  }
  template<typename T> const T *def_as() const;
  const lull::RenderDef *def_as_RenderDef() const {
    return def_type() == ComponentDefType_RenderDef ? static_cast<const lull::RenderDef *>(def()) : nullptr;
  }
  const lull::TextDef *def_as_TextDef() const {
    return def_type() == ComponentDefType_TextDef ? static_cast<const lull::TextDef *>(def()) : nullptr;
  }
  const lull::TransformDef *def_as_TransformDef() const {
    return def_type() == ComponentDefType_TransformDef ? static_cast<const lull::TransformDef *>(def()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_DEF_TYPE) &&
           VerifyOffset(verifier, VT_DEF) &&
           VerifyComponentDefType(verifier, def(), def_type()) &&
           verifier.EndTable();
  }
};

template<> inline const lull::RenderDef *ComponentDef::def_as<lull::RenderDef>() const {
  return def_as_RenderDef();
}

template<> inline const lull::TextDef *ComponentDef::def_as<lull::TextDef>() const {
  return def_as_TextDef();
}

template<> inline const lull::TransformDef *ComponentDef::def_as<lull::TransformDef>() const {
  return def_as_TransformDef();
}

struct ComponentDefBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_def_type(ComponentDefType def_type) {
    fbb_.AddElement<uint8_t>(ComponentDef::VT_DEF_TYPE, static_cast<uint8_t>(def_type), 0);
  }
  void add_def(flatbuffers::Offset<void> def) {
    fbb_.AddOffset(ComponentDef::VT_DEF, def);
  }
  ComponentDefBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ComponentDefBuilder &operator=(const ComponentDefBuilder &);
  flatbuffers::Offset<ComponentDef> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<ComponentDef>(end);
    return o;
  }
};

inline flatbuffers::Offset<ComponentDef> CreateComponentDef(
    flatbuffers::FlatBufferBuilder &_fbb,
    ComponentDefType def_type = ComponentDefType_NONE,
    flatbuffers::Offset<void> def = 0) {
  ComponentDefBuilder builder_(_fbb);
  builder_.add_def(def);
  builder_.add_def_type(def_type);
  return builder_.Finish();
}

struct EntityDef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "EntityDef";
  }
  enum {
    VT_COMPONENTS = 4,
    VT_CHILDREN = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<ComponentDef>> *components() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ComponentDef>> *>(VT_COMPONENTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<EntityDef>> *children() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<EntityDef>> *>(VT_CHILDREN);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COMPONENTS) &&
           verifier.Verify(components()) &&
           verifier.VerifyVectorOfTables(components()) &&
           VerifyOffset(verifier, VT_CHILDREN) &&
           verifier.Verify(children()) &&
           verifier.VerifyVectorOfTables(children()) &&
           verifier.EndTable();
  }
};

struct EntityDefBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_components(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ComponentDef>>> components) {
    fbb_.AddOffset(EntityDef::VT_COMPONENTS, components);
  }
  void add_children(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EntityDef>>> children) {
    fbb_.AddOffset(EntityDef::VT_CHILDREN, children);
  }
  EntityDefBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EntityDefBuilder &operator=(const EntityDefBuilder &);
  flatbuffers::Offset<EntityDef> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<EntityDef>(end);
    return o;
  }
};

inline flatbuffers::Offset<EntityDef> CreateEntityDef(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ComponentDef>>> components = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EntityDef>>> children = 0) {
  EntityDefBuilder builder_(_fbb);
  builder_.add_children(children);
  builder_.add_components(components);
  return builder_.Finish();
}

inline flatbuffers::Offset<EntityDef> CreateEntityDefDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<ComponentDef>> *components = nullptr,
    const std::vector<flatbuffers::Offset<EntityDef>> *children = nullptr) {
  return CreateEntityDef(
      _fbb,
      components ? _fbb.CreateVector<flatbuffers::Offset<ComponentDef>>(*components) : 0,
      children ? _fbb.CreateVector<flatbuffers::Offset<EntityDef>>(*children) : 0);
}

inline bool VerifyComponentDefType(flatbuffers::Verifier &verifier, const void *obj, ComponentDefType type) {
  switch (type) {
    case ComponentDefType_NONE: {
      return true;
    }
    case ComponentDefType_RenderDef: {
      auto ptr = reinterpret_cast<const lull::RenderDef *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ComponentDefType_TextDef: {
      auto ptr = reinterpret_cast<const lull::TextDef *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ComponentDefType_TransformDef: {
      auto ptr = reinterpret_cast<const lull::TransformDef *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyComponentDefTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyComponentDefType(
        verifier,  values->Get(i), types->GetEnum<ComponentDefType>(i))) {
      return false;
    }
  }
  return true;
}

inline const EntityDef *GetEntityDef(const void *buf) {
  return flatbuffers::GetRoot<EntityDef>(buf);
}

inline const char *EntityDefIdentifier() {
  return "ENTS";
}

inline bool EntityDefBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, EntityDefIdentifier());
}

inline bool VerifyEntityDefBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<EntityDef>(EntityDefIdentifier());
}

inline void FinishEntityDefBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<EntityDef> root) {
  fbb.Finish(root, EntityDefIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_ENTITY_H_