// Autogenerated code.  Do not edit.
#ifndef _LULLABY_LULLABY_GENERATED_ANIMATION_STATEGRAPH_GENERATED_H_
#define _LULLABY_LULLABY_GENERATED_ANIMATION_STATEGRAPH_GENERATED_H_

#include <type_traits>
#include <memory>
#include "flatbuffers/animation_stategraph_generated.h"
#include "lullaby/util/common_types.h"
#include "lullaby/util/color.h"
#include "lullaby/util/math.h"
#include "lullaby/util/optional.h"
#include "lullaby/util/typeid.h"
#include "common_generated.h"
#include "variant_def_generated.h"

namespace lull {
class FirstAnimationSelectorDefT;
class RandomAnimationSelectorDefT;
class ScriptedAnimationSelectorDefT;
class AnimationSelectorDefT;
class AnimationSignalDefT;
class AnimationTrackDefT;
class SignalPairT;
class AnimationTransitionDefT;
class AnimationStateDefT;
class AnimationStategraphDefT;
class FirstAnimationSelectorDefT {
 public:
  using FlatBufferType = FirstAnimationSelectorDef;

  FirstAnimationSelectorDefT() {}


  template <typename Archive>
  void SerializeFlatbuffer(Archive archive);
};

class RandomAnimationSelectorDefT {
 public:
  using FlatBufferType = RandomAnimationSelectorDef;

  RandomAnimationSelectorDefT() {}


  template <typename Archive>
  void SerializeFlatbuffer(Archive archive);
};

class ScriptedAnimationSelectorDefT {
 public:
  using FlatBufferType = ScriptedAnimationSelectorDef;

  ScriptedAnimationSelectorDefT() {}

  std::string code;

  template <typename Archive>
  void SerializeFlatbuffer(Archive archive);
};

class AnimationSelectorDefT {
 public:
  using FlatBufferType = AnimationSelectorDef;
  static const uint8_t kNone = AnimationSelectorDef_NONE;

  AnimationSelectorDefT() {}
  ~AnimationSelectorDefT() { reset(); }

  AnimationSelectorDefT(const AnimationSelectorDefT& rhs) { assign(rhs); }
  AnimationSelectorDefT& operator=(const AnimationSelectorDefT& rhs) {
    assign(rhs);
    return *this;
  }

  void reset();

  FlatBufferType type() const {
    return type_;
  }

  template <typename T>
  T* get() {
    return type_ == get_type<T>() ?
        reinterpret_cast<T*>(&data_) : nullptr;
  }

  template <typename T>
  const T* get() const {
    return type_ == get_type<T>() ?
        reinterpret_cast<const T*>(&data_) : nullptr;
  }

  template <typename T>
  T* set();

  template <typename Archive>
  void SerializeFlatbuffer(FlatBufferType type, Archive archive);

 private:
  void assign(const AnimationSelectorDefT& rhs);

  template <typename T>
  void destroy() {
    reinterpret_cast<T*>(&data_)->~T();
  }

  template <typename T>
  static FlatBufferType get_type() {
    return AnimationSelectorDef_NONE;
  }

  template <typename T>
  using Store = std::aligned_storage<sizeof(T), alignof(T)>;
  union Buffer {
    Store<lull::FirstAnimationSelectorDefT>::type FirstAnimationSelectorDef_;
    Store<lull::RandomAnimationSelectorDefT>::type RandomAnimationSelectorDef_;
    Store<lull::ScriptedAnimationSelectorDefT>::type ScriptedAnimationSelectorDef_;
  };
  Buffer data_;
  FlatBufferType type_ = AnimationSelectorDef_NONE;
};

class AnimationSignalDefT {
 public:
  using FlatBufferType = AnimationSignalDef;

  AnimationSignalDefT() {}

  lull::HashValue id = 0;
  float start_time_s = 0.0f;
  float end_time_s = 0.0f;
  std::string on_enter;
  std::string on_exit;

  template <typename Archive>
  void SerializeFlatbuffer(Archive archive);
};

class AnimationTrackDefT {
 public:
  using FlatBufferType = AnimationTrackDef;

  AnimationTrackDefT() {}

  std::string animation;
  float playback_speed = 1.0f;
  std::vector<lull::AnimationSignalDefT> signals;
  lull::VariantMapDefT selection_params;
  lull::HashValue animation_channel = 0;

  template <typename Archive>
  void SerializeFlatbuffer(Archive archive);
};

class SignalPairT {
 public:
  using FlatBufferType = SignalPair;

  SignalPairT() {}

  lull::HashValue from_signal = 0;
  lull::HashValue to_signal = 0;

  template <typename Archive>
  void SerializeFlatbuffer(Archive archive);
};

class AnimationTransitionDefT {
 public:
  using FlatBufferType = AnimationTransitionDef;

  AnimationTransitionDefT() {}

  lull::HashValue to_state = 0;
  float active_time_from_end_s = 0.0f;
  bool active_for_entire_time = 0;
  float blend_time_s = 0.0f;
  std::vector<lull::SignalPairT> signals;

  template <typename Archive>
  void SerializeFlatbuffer(Archive archive);
};

class AnimationStateDefT {
 public:
  using FlatBufferType = AnimationStateDef;

  AnimationStateDefT() {}

  lull::HashValue id = 0;
  lull::AnimationSelectorDefT selector;
  std::vector<lull::AnimationTrackDefT> tracks;
  std::vector<lull::AnimationTransitionDefT> transitions;
  uint32_t default_transition_index = 0;

  template <typename Archive>
  void SerializeFlatbuffer(Archive archive);
};

class AnimationStategraphDefT {
 public:
  using FlatBufferType = AnimationStategraphDef;

  AnimationStategraphDefT() {}

  std::vector<lull::AnimationStateDefT> states;

  template <typename Archive>
  void SerializeFlatbuffer(Archive archive);
};

template <typename Archive>
void FirstAnimationSelectorDefT::SerializeFlatbuffer(Archive archive) {
}

template <typename Archive>
void RandomAnimationSelectorDefT::SerializeFlatbuffer(Archive archive) {
}

template <typename Archive>
void ScriptedAnimationSelectorDefT::SerializeFlatbuffer(Archive archive) {
  archive.String(&code, 4);
}

inline void AnimationSelectorDefT::reset() {
  switch (type_) {
    case AnimationSelectorDef_FirstAnimationSelectorDef: {
      destroy<lull::FirstAnimationSelectorDefT>();
      break;
    }
    case AnimationSelectorDef_RandomAnimationSelectorDef: {
      destroy<lull::RandomAnimationSelectorDefT>();
      break;
    }
    case AnimationSelectorDef_ScriptedAnimationSelectorDef: {
      destroy<lull::ScriptedAnimationSelectorDefT>();
      break;
    }
    default:
      break;
  }
  type_ = AnimationSelectorDef_NONE;
}

inline void AnimationSelectorDefT::assign(const AnimationSelectorDefT& rhs) {
  reset();
  switch (rhs.type_) {
    case AnimationSelectorDef_FirstAnimationSelectorDef: {
      *set<lull::FirstAnimationSelectorDefT>() = *rhs.get<lull::FirstAnimationSelectorDefT>();
      break;
    }
    case AnimationSelectorDef_RandomAnimationSelectorDef: {
      *set<lull::RandomAnimationSelectorDefT>() = *rhs.get<lull::RandomAnimationSelectorDefT>();
      break;
    }
    case AnimationSelectorDef_ScriptedAnimationSelectorDef: {
      *set<lull::ScriptedAnimationSelectorDefT>() = *rhs.get<lull::ScriptedAnimationSelectorDefT>();
      break;
    }
    default:
      break;
  }
}

template <typename T>
T* AnimationSelectorDefT::set() {
  reset();
  type_ = get_type<T>();
  if (type_ != kNone) {
    return new (&data_) T();
  }
  return nullptr;
}

template <>
inline AnimationSelectorDef AnimationSelectorDefT::get_type<lull::FirstAnimationSelectorDefT>() {
  return AnimationSelectorDef_FirstAnimationSelectorDef;
}

template <>
inline AnimationSelectorDef AnimationSelectorDefT::get_type<lull::RandomAnimationSelectorDefT>() {
  return AnimationSelectorDef_RandomAnimationSelectorDef;
}

template <>
inline AnimationSelectorDef AnimationSelectorDefT::get_type<lull::ScriptedAnimationSelectorDefT>() {
  return AnimationSelectorDef_ScriptedAnimationSelectorDef;
}


template <typename Archive>
void AnimationSelectorDefT::SerializeFlatbuffer(FlatBufferType type, Archive archive) {
  switch (type) {
    case AnimationSelectorDef_FirstAnimationSelectorDef: {
      if (archive.IsDestructive()) {
        set<lull::FirstAnimationSelectorDefT>()->SerializeFlatbuffer(archive);
      } else {
        get<lull::FirstAnimationSelectorDefT>()->SerializeFlatbuffer(archive);
      }
      break;
    }
    case AnimationSelectorDef_RandomAnimationSelectorDef: {
      if (archive.IsDestructive()) {
        set<lull::RandomAnimationSelectorDefT>()->SerializeFlatbuffer(archive);
      } else {
        get<lull::RandomAnimationSelectorDefT>()->SerializeFlatbuffer(archive);
      }
      break;
    }
    case AnimationSelectorDef_ScriptedAnimationSelectorDef: {
      if (archive.IsDestructive()) {
        set<lull::ScriptedAnimationSelectorDefT>()->SerializeFlatbuffer(archive);
      } else {
        get<lull::ScriptedAnimationSelectorDefT>()->SerializeFlatbuffer(archive);
      }
      break;
    }
    default:
      if (archive.IsDestructive()) {
        reset();
      }
      break;
  }
}

template <typename Archive>
void AnimationSignalDefT::SerializeFlatbuffer(Archive archive) {
  archive.String(&on_enter, 10);
  archive.String(&on_exit, 12);
  archive.Scalar(&id, 4, 0);
  archive.Scalar(&start_time_s, 6, 0.0f);
  archive.Scalar(&end_time_s, 8, 0.0f);
}

template <typename Archive>
void AnimationTrackDefT::SerializeFlatbuffer(Archive archive) {
  archive.String(&animation, 4);
  archive.VectorOfTables(&signals, 8);
  archive.Table(&selection_params, 10);
  archive.Scalar(&playback_speed, 6, 1.0f);
  archive.Scalar(&animation_channel, 12, 0);
}

template <typename Archive>
void SignalPairT::SerializeFlatbuffer(Archive archive) {
  archive.Scalar(&from_signal, 0, 0);
  archive.Scalar(&to_signal, 4, 0);
}

template <typename Archive>
void AnimationTransitionDefT::SerializeFlatbuffer(Archive archive) {
  archive.VectorOfStructs(&signals, 12);
  archive.Scalar(&to_state, 4, 0);
  archive.Scalar(&active_time_from_end_s, 6, 0.0f);
  archive.Scalar(&active_for_entire_time, 8, 0);
  archive.Scalar(&blend_time_s, 10, 0.0f);
}

template <typename Archive>
void AnimationStateDefT::SerializeFlatbuffer(Archive archive) {
  archive.Union(&selector, 8, lull::AnimationSelectorDefT::kNone);
  archive.VectorOfTables(&tracks, 10);
  archive.VectorOfTables(&transitions, 12);
  archive.Scalar(&id, 4, 0);
  archive.Scalar(&default_transition_index, 14, 0);
}

template <typename Archive>
void AnimationStategraphDefT::SerializeFlatbuffer(Archive archive) {
  archive.VectorOfTables(&states, 4);
}

}  // namespace lull

LULLABY_SETUP_TYPEID(lull::FirstAnimationSelectorDefT);
LULLABY_SETUP_TYPEID(lull::RandomAnimationSelectorDefT);
LULLABY_SETUP_TYPEID(lull::ScriptedAnimationSelectorDefT);
LULLABY_SETUP_TYPEID(lull::AnimationSelectorDefT);
LULLABY_SETUP_TYPEID(lull::AnimationSignalDefT);
LULLABY_SETUP_TYPEID(lull::AnimationTrackDefT);
LULLABY_SETUP_TYPEID(lull::SignalPairT);
LULLABY_SETUP_TYPEID(lull::AnimationTransitionDefT);
LULLABY_SETUP_TYPEID(lull::AnimationStateDefT);
LULLABY_SETUP_TYPEID(lull::AnimationStategraphDefT);

#endif  // _LULLABY_LULLABY_GENERATED_ANIMATION_STATEGRAPH_GENERATED_H_

