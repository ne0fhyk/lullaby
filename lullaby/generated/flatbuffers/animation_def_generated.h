// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ANIMATIONDEF_LULL_H_
#define FLATBUFFERS_GENERATED_ANIMATIONDEF_LULL_H_

#include "flatbuffers/flatbuffers.h"

#include "common_generated.h"
#include "dispatcher_def_generated.h"
#include "variant_def_generated.h"

namespace lull {

struct AnimInstanceDef;

struct AnimTargetDef;

struct DefiningAnimDef;

struct AnimationDef;

/// An Animation is a set of curves, where each curve has a single
/// floating-point "value" for any given "time" value.  Each curve represents a
/// single "dimension" of the animation.  (For example, an animation for
/// position will have three curves representing the x, y, and z dimensions.)
///
/// Animations can be specified in two ways:
/// * Animation data files store curve data explicitly (either converted from
///   .fbx files using anim_pipeline or from .json files using flatc).
/// * Animation target values generate curves at runtime such that the curves
///   will end with the provided target values over the given amount of time.
///
/// An Animation is played on a specific Animation Channel.  The Animation
/// Channel determines how the data from the animation will be mapped to
/// Component data.  For example:
/// * "transform-position": A 3-dimensional channel that sets the position of an
///   entity via the TransformSystem.
/// * "transform-rotation": A 3-dimensional channel that sets the rotation of an
///   entity via the TransformSystem.  The data is expected to be in in Euler
///   angles.
/// * "transform-scale": A 3-dimensional channel that sets the scale of an
///   entity via the TransformSystem.
/// * "render-color": A 4-dimensional channel that sets the "color" uniform of
///   an entity via the RenderSystem.
/// This is just a small subset of potential channels.  The actual channels that
/// are setup for use will vary at a per-application level.
/// Provides a list of animation data files to be played on a given channel.
struct AnimInstanceDef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.AnimInstanceDef";
  }
  enum {
    VT_FILENAMES = 4,
    VT_CHANNEL = 6,
    VT_LOOPING = 8,
    VT_SPEED = 10,
    VT_START_DELAY = 12,
    VT_OFFSET = 14,
    VT_MULTIPLIER = 16,
    VT_BLEND_TIME = 18
  };
  /// A list of files from which to read animation data.  Curve data from the
  /// files will be mapped one at a time to the dimensions in the channel in the
  /// order they are found in the array of files.
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *filenames() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_FILENAMES);
  }
  /// The AnimationChannel on which to play the animations.
  const flatbuffers::String *channel() const {
    return GetPointer<const flatbuffers::String *>(VT_CHANNEL);
  }
  /// Indicates whether to loop the animation once it reaches the end.
  bool looping() const {
    return GetField<uint8_t>(VT_LOOPING, 0) != 0;
  }
  /// Playback speed, which applies as a multiple of the animation timestamp.
  float speed() const {
    return GetField<float>(VT_SPEED, 1.0f);
  }
  /// Time (in seconds) to delay starting the playback.
  float start_delay() const {
    return GetField<float>(VT_START_DELAY, 0.0f);
  }
  /// Optional values to be added to the calculated value from each curve of the
  /// animation before setting the component data.
  /// For animation curves that start at 0, this can be used to adjust the
  /// desired starting value of the animation specific to the Entity.
  const flatbuffers::Vector<float> *offset() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_OFFSET);
  }
  /// Optional values to multiplied to the calculated value from each curve of
  /// the animation before setting the component data.
  /// For animation curves that end at 1, this can be used to adjust the
  /// desired ending value of the animation specific to the Entity.  (The ending
  /// value will be equal to (offset + multiplier).
  const flatbuffers::Vector<float> *multiplier() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_MULTIPLIER);
  }
  /// Time (in seconds) to blend from the previous animation.
  float blend_time() const {
    return GetField<float>(VT_BLEND_TIME, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FILENAMES) &&
           verifier.Verify(filenames()) &&
           verifier.VerifyVectorOfStrings(filenames()) &&
           VerifyOffset(verifier, VT_CHANNEL) &&
           verifier.Verify(channel()) &&
           VerifyField<uint8_t>(verifier, VT_LOOPING) &&
           VerifyField<float>(verifier, VT_SPEED) &&
           VerifyField<float>(verifier, VT_START_DELAY) &&
           VerifyOffset(verifier, VT_OFFSET) &&
           verifier.Verify(offset()) &&
           VerifyOffset(verifier, VT_MULTIPLIER) &&
           verifier.Verify(multiplier()) &&
           VerifyField<float>(verifier, VT_BLEND_TIME) &&
           verifier.EndTable();
  }
};

struct AnimInstanceDefBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_filenames(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> filenames) {
    fbb_.AddOffset(AnimInstanceDef::VT_FILENAMES, filenames);
  }
  void add_channel(flatbuffers::Offset<flatbuffers::String> channel) {
    fbb_.AddOffset(AnimInstanceDef::VT_CHANNEL, channel);
  }
  void add_looping(bool looping) {
    fbb_.AddElement<uint8_t>(AnimInstanceDef::VT_LOOPING, static_cast<uint8_t>(looping), 0);
  }
  void add_speed(float speed) {
    fbb_.AddElement<float>(AnimInstanceDef::VT_SPEED, speed, 1.0f);
  }
  void add_start_delay(float start_delay) {
    fbb_.AddElement<float>(AnimInstanceDef::VT_START_DELAY, start_delay, 0.0f);
  }
  void add_offset(flatbuffers::Offset<flatbuffers::Vector<float>> offset) {
    fbb_.AddOffset(AnimInstanceDef::VT_OFFSET, offset);
  }
  void add_multiplier(flatbuffers::Offset<flatbuffers::Vector<float>> multiplier) {
    fbb_.AddOffset(AnimInstanceDef::VT_MULTIPLIER, multiplier);
  }
  void add_blend_time(float blend_time) {
    fbb_.AddElement<float>(AnimInstanceDef::VT_BLEND_TIME, blend_time, 0.0f);
  }
  explicit AnimInstanceDefBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnimInstanceDefBuilder &operator=(const AnimInstanceDefBuilder &);
  flatbuffers::Offset<AnimInstanceDef> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnimInstanceDef>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnimInstanceDef> CreateAnimInstanceDef(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> filenames = 0,
    flatbuffers::Offset<flatbuffers::String> channel = 0,
    bool looping = false,
    float speed = 1.0f,
    float start_delay = 0.0f,
    flatbuffers::Offset<flatbuffers::Vector<float>> offset = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> multiplier = 0,
    float blend_time = 0.0f) {
  AnimInstanceDefBuilder builder_(_fbb);
  builder_.add_blend_time(blend_time);
  builder_.add_multiplier(multiplier);
  builder_.add_offset(offset);
  builder_.add_start_delay(start_delay);
  builder_.add_speed(speed);
  builder_.add_channel(channel);
  builder_.add_filenames(filenames);
  builder_.add_looping(looping);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimInstanceDef> CreateAnimInstanceDefDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *filenames = nullptr,
    const char *channel = nullptr,
    bool looping = false,
    float speed = 1.0f,
    float start_delay = 0.0f,
    const std::vector<float> *offset = nullptr,
    const std::vector<float> *multiplier = nullptr,
    float blend_time = 0.0f) {
  return lull::CreateAnimInstanceDef(
      _fbb,
      filenames ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*filenames) : 0,
      channel ? _fbb.CreateString(channel) : 0,
      looping,
      speed,
      start_delay,
      offset ? _fbb.CreateVector<float>(*offset) : 0,
      multiplier ? _fbb.CreateVector<float>(*multiplier) : 0,
      blend_time);
}

/// Specifies how to drive the data for an animation channel towards target
/// values over the specified amount of time.
struct AnimTargetDef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.AnimTargetDef";
  }
  enum {
    VT_CHANNEL = 4,
    VT_VALUES = 6,
    VT_TIME_MS = 8,
    VT_START_DELAY_MS = 10
  };
  /// The AnimationChannel on which to set these targets.
  const flatbuffers::String *channel() const {
    return GetPointer<const flatbuffers::String *>(VT_CHANNEL);
  }
  /// The target values for the channel.
  const flatbuffers::Vector<float> *values() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_VALUES);
  }
  /// The amount of time (in milliseconds) to take to reach the target values.
  int32_t time_ms() const {
    return GetField<int32_t>(VT_TIME_MS, 0);
  }
  /// The amount of time (in milliseconds) to delay starting the animation.
  int32_t start_delay_ms() const {
    return GetField<int32_t>(VT_START_DELAY_MS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CHANNEL) &&
           verifier.Verify(channel()) &&
           VerifyOffset(verifier, VT_VALUES) &&
           verifier.Verify(values()) &&
           VerifyField<int32_t>(verifier, VT_TIME_MS) &&
           VerifyField<int32_t>(verifier, VT_START_DELAY_MS) &&
           verifier.EndTable();
  }
};

struct AnimTargetDefBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_channel(flatbuffers::Offset<flatbuffers::String> channel) {
    fbb_.AddOffset(AnimTargetDef::VT_CHANNEL, channel);
  }
  void add_values(flatbuffers::Offset<flatbuffers::Vector<float>> values) {
    fbb_.AddOffset(AnimTargetDef::VT_VALUES, values);
  }
  void add_time_ms(int32_t time_ms) {
    fbb_.AddElement<int32_t>(AnimTargetDef::VT_TIME_MS, time_ms, 0);
  }
  void add_start_delay_ms(int32_t start_delay_ms) {
    fbb_.AddElement<int32_t>(AnimTargetDef::VT_START_DELAY_MS, start_delay_ms, 0);
  }
  explicit AnimTargetDefBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnimTargetDefBuilder &operator=(const AnimTargetDefBuilder &);
  flatbuffers::Offset<AnimTargetDef> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnimTargetDef>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnimTargetDef> CreateAnimTargetDef(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> channel = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> values = 0,
    int32_t time_ms = 0,
    int32_t start_delay_ms = 0) {
  AnimTargetDefBuilder builder_(_fbb);
  builder_.add_start_delay_ms(start_delay_ms);
  builder_.add_time_ms(time_ms);
  builder_.add_values(values);
  builder_.add_channel(channel);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimTargetDef> CreateAnimTargetDefDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *channel = nullptr,
    const std::vector<float> *values = nullptr,
    int32_t time_ms = 0,
    int32_t start_delay_ms = 0) {
  return lull::CreateAnimTargetDef(
      _fbb,
      channel ? _fbb.CreateString(channel) : 0,
      values ? _fbb.CreateVector<float>(*values) : 0,
      time_ms,
      start_delay_ms);
}

/// Specifies a "defining animation" that is used to correctly initialize
/// animation channels which will be playing an animation from a set of related
/// animations.
struct DefiningAnimDef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.DefiningAnimDef";
  }
  enum {
    VT_FILENAME = 4,
    VT_CHANNEL = 6
  };
  /// The file containing the "defining animation".
  const flatbuffers::String *filename() const {
    return GetPointer<const flatbuffers::String *>(VT_FILENAME);
  }
  /// The channel associated with the "defining animation".
  const flatbuffers::String *channel() const {
    return GetPointer<const flatbuffers::String *>(VT_CHANNEL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FILENAME) &&
           verifier.Verify(filename()) &&
           VerifyOffset(verifier, VT_CHANNEL) &&
           verifier.Verify(channel()) &&
           verifier.EndTable();
  }
};

struct DefiningAnimDefBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_filename(flatbuffers::Offset<flatbuffers::String> filename) {
    fbb_.AddOffset(DefiningAnimDef::VT_FILENAME, filename);
  }
  void add_channel(flatbuffers::Offset<flatbuffers::String> channel) {
    fbb_.AddOffset(DefiningAnimDef::VT_CHANNEL, channel);
  }
  explicit DefiningAnimDefBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DefiningAnimDefBuilder &operator=(const DefiningAnimDefBuilder &);
  flatbuffers::Offset<DefiningAnimDef> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DefiningAnimDef>(end);
    return o;
  }
};

inline flatbuffers::Offset<DefiningAnimDef> CreateDefiningAnimDef(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> filename = 0,
    flatbuffers::Offset<flatbuffers::String> channel = 0) {
  DefiningAnimDefBuilder builder_(_fbb);
  builder_.add_channel(channel);
  builder_.add_filename(filename);
  return builder_.Finish();
}

inline flatbuffers::Offset<DefiningAnimDef> CreateDefiningAnimDefDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *filename = nullptr,
    const char *channel = nullptr) {
  return lull::CreateDefiningAnimDef(
      _fbb,
      filename ? _fbb.CreateString(filename) : 0,
      channel ? _fbb.CreateString(channel) : 0);
}

/// Defines a set of animations or targets to play on an Entity.
struct AnimationDef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.AnimationDef";
  }
  enum {
    VT_ANIMATIONS = 4,
    VT_TARGETS = 6,
    VT_ON_COMPLETE_EVENTS = 8,
    VT_ON_SUCCESS_EVENTS = 10,
    VT_ON_CANCELLED_EVENTS = 12,
    VT_DEFINING_ANIMATION = 14
  };
  const flatbuffers::Vector<flatbuffers::Offset<AnimInstanceDef>> *animations() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimInstanceDef>> *>(VT_ANIMATIONS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<AnimTargetDef>> *targets() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimTargetDef>> *>(VT_TARGETS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<EventDef>> *on_complete_events() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<EventDef>> *>(VT_ON_COMPLETE_EVENTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<EventDef>> *on_success_events() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<EventDef>> *>(VT_ON_SUCCESS_EVENTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<EventDef>> *on_cancelled_events() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<EventDef>> *>(VT_ON_CANCELLED_EVENTS);
  }
  /// The defining animation is contains the entire skeleton of the animation.
  /// Specifically, it ensures that the animation channel is initialized such
  /// that it will be able to animate any animation using the same skeleton,
  /// regardless of if the animation itself animates all the bones.  The term
  /// "defining animation" comes from the motive library and can be generated
  const DefiningAnimDef *defining_animation() const {
    return GetPointer<const DefiningAnimDef *>(VT_DEFINING_ANIMATION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ANIMATIONS) &&
           verifier.Verify(animations()) &&
           verifier.VerifyVectorOfTables(animations()) &&
           VerifyOffset(verifier, VT_TARGETS) &&
           verifier.Verify(targets()) &&
           verifier.VerifyVectorOfTables(targets()) &&
           VerifyOffset(verifier, VT_ON_COMPLETE_EVENTS) &&
           verifier.Verify(on_complete_events()) &&
           verifier.VerifyVectorOfTables(on_complete_events()) &&
           VerifyOffset(verifier, VT_ON_SUCCESS_EVENTS) &&
           verifier.Verify(on_success_events()) &&
           verifier.VerifyVectorOfTables(on_success_events()) &&
           VerifyOffset(verifier, VT_ON_CANCELLED_EVENTS) &&
           verifier.Verify(on_cancelled_events()) &&
           verifier.VerifyVectorOfTables(on_cancelled_events()) &&
           VerifyOffset(verifier, VT_DEFINING_ANIMATION) &&
           verifier.VerifyTable(defining_animation()) &&
           verifier.EndTable();
  }
};

struct AnimationDefBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_animations(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimInstanceDef>>> animations) {
    fbb_.AddOffset(AnimationDef::VT_ANIMATIONS, animations);
  }
  void add_targets(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimTargetDef>>> targets) {
    fbb_.AddOffset(AnimationDef::VT_TARGETS, targets);
  }
  void add_on_complete_events(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EventDef>>> on_complete_events) {
    fbb_.AddOffset(AnimationDef::VT_ON_COMPLETE_EVENTS, on_complete_events);
  }
  void add_on_success_events(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EventDef>>> on_success_events) {
    fbb_.AddOffset(AnimationDef::VT_ON_SUCCESS_EVENTS, on_success_events);
  }
  void add_on_cancelled_events(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EventDef>>> on_cancelled_events) {
    fbb_.AddOffset(AnimationDef::VT_ON_CANCELLED_EVENTS, on_cancelled_events);
  }
  void add_defining_animation(flatbuffers::Offset<DefiningAnimDef> defining_animation) {
    fbb_.AddOffset(AnimationDef::VT_DEFINING_ANIMATION, defining_animation);
  }
  explicit AnimationDefBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnimationDefBuilder &operator=(const AnimationDefBuilder &);
  flatbuffers::Offset<AnimationDef> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnimationDef>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnimationDef> CreateAnimationDef(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimInstanceDef>>> animations = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimTargetDef>>> targets = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EventDef>>> on_complete_events = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EventDef>>> on_success_events = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EventDef>>> on_cancelled_events = 0,
    flatbuffers::Offset<DefiningAnimDef> defining_animation = 0) {
  AnimationDefBuilder builder_(_fbb);
  builder_.add_defining_animation(defining_animation);
  builder_.add_on_cancelled_events(on_cancelled_events);
  builder_.add_on_success_events(on_success_events);
  builder_.add_on_complete_events(on_complete_events);
  builder_.add_targets(targets);
  builder_.add_animations(animations);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimationDef> CreateAnimationDefDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<AnimInstanceDef>> *animations = nullptr,
    const std::vector<flatbuffers::Offset<AnimTargetDef>> *targets = nullptr,
    const std::vector<flatbuffers::Offset<EventDef>> *on_complete_events = nullptr,
    const std::vector<flatbuffers::Offset<EventDef>> *on_success_events = nullptr,
    const std::vector<flatbuffers::Offset<EventDef>> *on_cancelled_events = nullptr,
    flatbuffers::Offset<DefiningAnimDef> defining_animation = 0) {
  return lull::CreateAnimationDef(
      _fbb,
      animations ? _fbb.CreateVector<flatbuffers::Offset<AnimInstanceDef>>(*animations) : 0,
      targets ? _fbb.CreateVector<flatbuffers::Offset<AnimTargetDef>>(*targets) : 0,
      on_complete_events ? _fbb.CreateVector<flatbuffers::Offset<EventDef>>(*on_complete_events) : 0,
      on_success_events ? _fbb.CreateVector<flatbuffers::Offset<EventDef>>(*on_success_events) : 0,
      on_cancelled_events ? _fbb.CreateVector<flatbuffers::Offset<EventDef>>(*on_cancelled_events) : 0,
      defining_animation);
}

}  // namespace lull

#endif  // FLATBUFFERS_GENERATED_ANIMATIONDEF_LULL_H_
