// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_AUDIORESPONSEDEF_LULL_H_
#define FLATBUFFERS_GENERATED_AUDIORESPONSEDEF_LULL_H_

#include "flatbuffers/flatbuffers.h"

#include "audio_playback_types_generated.h"
#include "common_generated.h"
#include "dispatcher_def_generated.h"
#include "variant_def_generated.h"

namespace lull {

struct AudioResponseDef;

/// A response that plays a sound based on an input event.  (For example,
/// playing a sound when an Entity is clicked.)
struct AudioResponseDef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.AudioResponseDef";
  }
  enum {
    VT_INPUTS = 4,
    VT_SOUND = 6,
    VT_RANDOM_SOUNDS = 8,
    VT_PLAYBACK_TYPE = 10,
    VT_VOLUME = 12,
    VT_SOURCE_TYPE = 14,
    VT_SPATIAL_DIRECTIVITY_ALPHA = 16,
    VT_SPATIAL_DIRECTIVITY_ORDER = 18
  };
  /// One or more inputs that trigger the response.  See dispatcher_def.fbs for
  /// more information.
  const flatbuffers::Vector<flatbuffers::Offset<EventDef>> *inputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<EventDef>> *>(VT_INPUTS);
  }
  /// The name of the sound to play.
  const flatbuffers::String *sound() const {
    return GetPointer<const flatbuffers::String *>(VT_SOUND);
  }
  /// An array of sounds, of which one will be picked at random in response.
  /// Only used if the 'sound' field is not present.
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *random_sounds() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_RANDOM_SOUNDS);
  }
  /// How this sound should be loaded and played. By default, response sounds
  /// are preloaded, and will skip playing if they are not done loading.
  AudioPlaybackType playback_type() const {
    return static_cast<AudioPlaybackType>(GetField<int32_t>(VT_PLAYBACK_TYPE, 0));
  }
  /// The volume level, in the range [0,+inf], where values higher than 1.0
  /// indicate gain.
  float volume() const {
    return GetField<float>(VT_VOLUME, 1.0f);
  }
  /// The type of audio source.
  AudioSourceType source_type() const {
    return static_cast<AudioSourceType>(GetField<int32_t>(VT_SOURCE_TYPE, 1));
  }
  /// The directivity constant "alpha". This value is a weighting balance
  /// between a figure 8 pattern and omnidirectional pattern for source
  /// emission. Range of [0, 1], with a value of 0.5 results in a cardioid
  /// pattern.
  /// This value will be only be checked when source_type = Spatialized. If it
  /// is not in the range [0, 1], it will be ignored and directivity will not be
  /// set for this sound.
  float spatial_directivity_alpha() const {
    return GetField<float>(VT_SPATIAL_DIRECTIVITY_ALPHA, -1.0f);
  }
  /// The directivity constant "order". This value is applied to computed
  /// directivity. Higher values will result in narrower and sharper directivity
  /// patterns. Range of [1, inf).
  /// This value will be only be checked when source_type = Spatialized. If it
  /// is not in the range [1, inf), it will be ignored and directivity will not
  /// be set for this sound.
  float spatial_directivity_order() const {
    return GetField<float>(VT_SPATIAL_DIRECTIVITY_ORDER, -1.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.Verify(inputs()) &&
           verifier.VerifyVectorOfTables(inputs()) &&
           VerifyOffset(verifier, VT_SOUND) &&
           verifier.Verify(sound()) &&
           VerifyOffset(verifier, VT_RANDOM_SOUNDS) &&
           verifier.Verify(random_sounds()) &&
           verifier.VerifyVectorOfStrings(random_sounds()) &&
           VerifyField<int32_t>(verifier, VT_PLAYBACK_TYPE) &&
           VerifyField<float>(verifier, VT_VOLUME) &&
           VerifyField<int32_t>(verifier, VT_SOURCE_TYPE) &&
           VerifyField<float>(verifier, VT_SPATIAL_DIRECTIVITY_ALPHA) &&
           VerifyField<float>(verifier, VT_SPATIAL_DIRECTIVITY_ORDER) &&
           verifier.EndTable();
  }
};

struct AudioResponseDefBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_inputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EventDef>>> inputs) {
    fbb_.AddOffset(AudioResponseDef::VT_INPUTS, inputs);
  }
  void add_sound(flatbuffers::Offset<flatbuffers::String> sound) {
    fbb_.AddOffset(AudioResponseDef::VT_SOUND, sound);
  }
  void add_random_sounds(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> random_sounds) {
    fbb_.AddOffset(AudioResponseDef::VT_RANDOM_SOUNDS, random_sounds);
  }
  void add_playback_type(AudioPlaybackType playback_type) {
    fbb_.AddElement<int32_t>(AudioResponseDef::VT_PLAYBACK_TYPE, static_cast<int32_t>(playback_type), 0);
  }
  void add_volume(float volume) {
    fbb_.AddElement<float>(AudioResponseDef::VT_VOLUME, volume, 1.0f);
  }
  void add_source_type(AudioSourceType source_type) {
    fbb_.AddElement<int32_t>(AudioResponseDef::VT_SOURCE_TYPE, static_cast<int32_t>(source_type), 1);
  }
  void add_spatial_directivity_alpha(float spatial_directivity_alpha) {
    fbb_.AddElement<float>(AudioResponseDef::VT_SPATIAL_DIRECTIVITY_ALPHA, spatial_directivity_alpha, -1.0f);
  }
  void add_spatial_directivity_order(float spatial_directivity_order) {
    fbb_.AddElement<float>(AudioResponseDef::VT_SPATIAL_DIRECTIVITY_ORDER, spatial_directivity_order, -1.0f);
  }
  explicit AudioResponseDefBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AudioResponseDefBuilder &operator=(const AudioResponseDefBuilder &);
  flatbuffers::Offset<AudioResponseDef> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AudioResponseDef>(end);
    return o;
  }
};

inline flatbuffers::Offset<AudioResponseDef> CreateAudioResponseDef(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EventDef>>> inputs = 0,
    flatbuffers::Offset<flatbuffers::String> sound = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> random_sounds = 0,
    AudioPlaybackType playback_type = AudioPlaybackType_PlayIfReady,
    float volume = 1.0f,
    AudioSourceType source_type = AudioSourceType_Spatialized,
    float spatial_directivity_alpha = -1.0f,
    float spatial_directivity_order = -1.0f) {
  AudioResponseDefBuilder builder_(_fbb);
  builder_.add_spatial_directivity_order(spatial_directivity_order);
  builder_.add_spatial_directivity_alpha(spatial_directivity_alpha);
  builder_.add_source_type(source_type);
  builder_.add_volume(volume);
  builder_.add_playback_type(playback_type);
  builder_.add_random_sounds(random_sounds);
  builder_.add_sound(sound);
  builder_.add_inputs(inputs);
  return builder_.Finish();
}

inline flatbuffers::Offset<AudioResponseDef> CreateAudioResponseDefDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<EventDef>> *inputs = nullptr,
    const char *sound = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *random_sounds = nullptr,
    AudioPlaybackType playback_type = AudioPlaybackType_PlayIfReady,
    float volume = 1.0f,
    AudioSourceType source_type = AudioSourceType_Spatialized,
    float spatial_directivity_alpha = -1.0f,
    float spatial_directivity_order = -1.0f) {
  return lull::CreateAudioResponseDef(
      _fbb,
      inputs ? _fbb.CreateVector<flatbuffers::Offset<EventDef>>(*inputs) : 0,
      sound ? _fbb.CreateString(sound) : 0,
      random_sounds ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*random_sounds) : 0,
      playback_type,
      volume,
      source_type,
      spatial_directivity_alpha,
      spatial_directivity_order);
}

}  // namespace lull

#endif  // FLATBUFFERS_GENERATED_AUDIORESPONSEDEF_LULL_H_
