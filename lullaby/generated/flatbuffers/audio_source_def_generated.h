// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_AUDIOSOURCEDEF_LULL_H_
#define FLATBUFFERS_GENERATED_AUDIOSOURCEDEF_LULL_H_

#include "flatbuffers/flatbuffers.h"

#include "audio_playback_types_generated.h"
#include "common_generated.h"

namespace lull {

struct AudioSourceDef;

/// Associates a sound source with the entity.
struct AudioSourceDef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.AudioSourceDef";
  }
  enum {
    VT_SOUND = 4,
    VT_VOLUME = 6,
    VT_LOOP = 8,
    VT_SOURCE_TYPE = 10,
    VT_PLAYBACK_TYPE = 12,
    VT_SPATIAL_DIRECTIVITY_ALPHA = 14,
    VT_SPATIAL_DIRECTIVITY_ORDER = 16
  };
  /// The filename of the sound file to play.
  const flatbuffers::String *sound() const {
    return GetPointer<const flatbuffers::String *>(VT_SOUND);
  }
  /// The volume level, in the range [0,+inf], where values higher than 1.0
  /// indicate gain.
  float volume() const {
    return GetField<float>(VT_VOLUME, 1.0f);
  }
  /// Whether to loop the sound.
  bool loop() const {
    return GetField<uint8_t>(VT_LOOP, 0) != 0;
  }
  /// The type of audio source.
  AudioSourceType source_type() const {
    return static_cast<AudioSourceType>(GetField<int32_t>(VT_SOURCE_TYPE, 1));
  }
  /// How this sound should be loaded and played. Sources stream by default,
  /// ensuring they can begin playback as quickly as possible.
  AudioPlaybackType playback_type() const {
    return static_cast<AudioPlaybackType>(GetField<int32_t>(VT_PLAYBACK_TYPE, 2));
  }
  /// The directivity constant "alpha". This value is a weighting balance
  /// between a figure 8 pattern and omnidirectional pattern for source
  /// emission. Range of [0, 1], with a value of 0.5 results in a cardioid
  /// pattern.
  /// This value will be only be checked when source_type = Spatialized. If it
  /// is not in the range [0, 1], it will be ignored and directivity will not be
  /// set for this sound.
  float spatial_directivity_alpha() const {
    return GetField<float>(VT_SPATIAL_DIRECTIVITY_ALPHA, -1.0f);
  }
  /// The directivity constant "order". This value is applied to computed
  /// directivity. Higher values will result in narrower and sharper directivity
  /// patterns. Range of [1, inf).
  /// This value will be only be checked when source_type = Spatialized. If it
  /// is not in the range [1, inf), it will be ignored and directivity will not
  /// be set for this sound.
  float spatial_directivity_order() const {
    return GetField<float>(VT_SPATIAL_DIRECTIVITY_ORDER, -1.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SOUND) &&
           verifier.Verify(sound()) &&
           VerifyField<float>(verifier, VT_VOLUME) &&
           VerifyField<uint8_t>(verifier, VT_LOOP) &&
           VerifyField<int32_t>(verifier, VT_SOURCE_TYPE) &&
           VerifyField<int32_t>(verifier, VT_PLAYBACK_TYPE) &&
           VerifyField<float>(verifier, VT_SPATIAL_DIRECTIVITY_ALPHA) &&
           VerifyField<float>(verifier, VT_SPATIAL_DIRECTIVITY_ORDER) &&
           verifier.EndTable();
  }
};

struct AudioSourceDefBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sound(flatbuffers::Offset<flatbuffers::String> sound) {
    fbb_.AddOffset(AudioSourceDef::VT_SOUND, sound);
  }
  void add_volume(float volume) {
    fbb_.AddElement<float>(AudioSourceDef::VT_VOLUME, volume, 1.0f);
  }
  void add_loop(bool loop) {
    fbb_.AddElement<uint8_t>(AudioSourceDef::VT_LOOP, static_cast<uint8_t>(loop), 0);
  }
  void add_source_type(AudioSourceType source_type) {
    fbb_.AddElement<int32_t>(AudioSourceDef::VT_SOURCE_TYPE, static_cast<int32_t>(source_type), 1);
  }
  void add_playback_type(AudioPlaybackType playback_type) {
    fbb_.AddElement<int32_t>(AudioSourceDef::VT_PLAYBACK_TYPE, static_cast<int32_t>(playback_type), 2);
  }
  void add_spatial_directivity_alpha(float spatial_directivity_alpha) {
    fbb_.AddElement<float>(AudioSourceDef::VT_SPATIAL_DIRECTIVITY_ALPHA, spatial_directivity_alpha, -1.0f);
  }
  void add_spatial_directivity_order(float spatial_directivity_order) {
    fbb_.AddElement<float>(AudioSourceDef::VT_SPATIAL_DIRECTIVITY_ORDER, spatial_directivity_order, -1.0f);
  }
  explicit AudioSourceDefBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AudioSourceDefBuilder &operator=(const AudioSourceDefBuilder &);
  flatbuffers::Offset<AudioSourceDef> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AudioSourceDef>(end);
    return o;
  }
};

inline flatbuffers::Offset<AudioSourceDef> CreateAudioSourceDef(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> sound = 0,
    float volume = 1.0f,
    bool loop = false,
    AudioSourceType source_type = AudioSourceType_Spatialized,
    AudioPlaybackType playback_type = AudioPlaybackType_Stream,
    float spatial_directivity_alpha = -1.0f,
    float spatial_directivity_order = -1.0f) {
  AudioSourceDefBuilder builder_(_fbb);
  builder_.add_spatial_directivity_order(spatial_directivity_order);
  builder_.add_spatial_directivity_alpha(spatial_directivity_alpha);
  builder_.add_playback_type(playback_type);
  builder_.add_source_type(source_type);
  builder_.add_volume(volume);
  builder_.add_sound(sound);
  builder_.add_loop(loop);
  return builder_.Finish();
}

inline flatbuffers::Offset<AudioSourceDef> CreateAudioSourceDefDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *sound = nullptr,
    float volume = 1.0f,
    bool loop = false,
    AudioSourceType source_type = AudioSourceType_Spatialized,
    AudioPlaybackType playback_type = AudioPlaybackType_Stream,
    float spatial_directivity_alpha = -1.0f,
    float spatial_directivity_order = -1.0f) {
  return lull::CreateAudioSourceDef(
      _fbb,
      sound ? _fbb.CreateString(sound) : 0,
      volume,
      loop,
      source_type,
      playback_type,
      spatial_directivity_alpha,
      spatial_directivity_order);
}

inline const lull::AudioSourceDef *GetAudioSourceDef(const void *buf) {
  return flatbuffers::GetRoot<lull::AudioSourceDef>(buf);
}

inline bool VerifyAudioSourceDefBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<lull::AudioSourceDef>(nullptr);
}

inline void FinishAudioSourceDefBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<lull::AudioSourceDef> root) {
  fbb.Finish(root);
}

}  // namespace lull

#endif  // FLATBUFFERS_GENERATED_AUDIOSOURCEDEF_LULL_H_
