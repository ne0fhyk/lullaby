// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CURSORDEF_LULL_H_
#define FLATBUFFERS_GENERATED_CURSORDEF_LULL_H_

#include "flatbuffers/flatbuffers.h"

#include "common_generated.h"

namespace lull {

struct CursorDef;

/// Configures a cursor to display at the end of an input collision ray.
/// Apps should consider reusing: lullaby/data/blueprints/reticle.json.
/// In case of changing any of these values, please update reticle_template.fbs.
struct CursorDef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.CursorDef";
  }
  enum {
    VT_RING_ACTIVE_DIAMETER = 4,
    VT_RING_INACTIVE_DIAMETER = 6,
    VT_HIT_COLOR = 8,
    VT_NO_HIT_COLOR = 10,
    VT_NO_HIT_DISTANCE = 12,
    VT_INNER_HOLE = 14,
    VT_INNER_RING_END = 16,
    VT_INNER_RING_THICKNESS = 18,
    VT_MID_RING_END = 20,
    VT_MID_RING_OPACITY = 22,
    VT_DEVICE = 24
  };
  float ring_active_diameter() const {
    return GetField<float>(VT_RING_ACTIVE_DIAMETER, 1.0f);
  }
  float ring_inactive_diameter() const {
    return GetField<float>(VT_RING_INACTIVE_DIAMETER, 1.0f);
  }
  const Color *hit_color() const {
    return GetStruct<const Color *>(VT_HIT_COLOR);
  }
  const Color *no_hit_color() const {
    return GetStruct<const Color *>(VT_NO_HIT_COLOR);
  }
  float no_hit_distance() const {
    return GetField<float>(VT_NO_HIT_DISTANCE, 2.0f);
  }
  /// Next 5 values are all in the range of [0-1], with 1 being the full radius
  /// of the ring_diameter.
  /// Distance from center to start of solid color ring.
  /// This - |inner_ring_thickness| will be the distance to the start of color.
  float inner_hole() const {
    return GetField<float>(VT_INNER_HOLE, 0.0f);
  }
  /// Distance from center to end of solid color ring.
  /// This + |inner_ring_thickness| will be the distance to the end of color.
  float inner_ring_end() const {
    return GetField<float>(VT_INNER_RING_END, 0.177f);
  }
  /// Feathering that will be applied inside |inner_hole| and outside
  /// |inner_ring_end|.
  float inner_ring_thickness() const {
    return GetField<float>(VT_INNER_RING_THICKNESS, 0.14f);
  }
  /// Distance from center to end of black ring.
  float mid_ring_end() const {
    return GetField<float>(VT_MID_RING_END, 0.177f);
  }
  /// Opacity of black ring outside of the colored ring.
  float mid_ring_opacity() const {
    return GetField<float>(VT_MID_RING_OPACITY, 0.22f);
  }
  /// What device the cursor should be generated by.
  DeviceType device() const {
    return static_cast<DeviceType>(GetField<int32_t>(VT_DEVICE, 3));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_RING_ACTIVE_DIAMETER) &&
           VerifyField<float>(verifier, VT_RING_INACTIVE_DIAMETER) &&
           VerifyField<Color>(verifier, VT_HIT_COLOR) &&
           VerifyField<Color>(verifier, VT_NO_HIT_COLOR) &&
           VerifyField<float>(verifier, VT_NO_HIT_DISTANCE) &&
           VerifyField<float>(verifier, VT_INNER_HOLE) &&
           VerifyField<float>(verifier, VT_INNER_RING_END) &&
           VerifyField<float>(verifier, VT_INNER_RING_THICKNESS) &&
           VerifyField<float>(verifier, VT_MID_RING_END) &&
           VerifyField<float>(verifier, VT_MID_RING_OPACITY) &&
           VerifyField<int32_t>(verifier, VT_DEVICE) &&
           verifier.EndTable();
  }
};

struct CursorDefBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ring_active_diameter(float ring_active_diameter) {
    fbb_.AddElement<float>(CursorDef::VT_RING_ACTIVE_DIAMETER, ring_active_diameter, 1.0f);
  }
  void add_ring_inactive_diameter(float ring_inactive_diameter) {
    fbb_.AddElement<float>(CursorDef::VT_RING_INACTIVE_DIAMETER, ring_inactive_diameter, 1.0f);
  }
  void add_hit_color(const Color *hit_color) {
    fbb_.AddStruct(CursorDef::VT_HIT_COLOR, hit_color);
  }
  void add_no_hit_color(const Color *no_hit_color) {
    fbb_.AddStruct(CursorDef::VT_NO_HIT_COLOR, no_hit_color);
  }
  void add_no_hit_distance(float no_hit_distance) {
    fbb_.AddElement<float>(CursorDef::VT_NO_HIT_DISTANCE, no_hit_distance, 2.0f);
  }
  void add_inner_hole(float inner_hole) {
    fbb_.AddElement<float>(CursorDef::VT_INNER_HOLE, inner_hole, 0.0f);
  }
  void add_inner_ring_end(float inner_ring_end) {
    fbb_.AddElement<float>(CursorDef::VT_INNER_RING_END, inner_ring_end, 0.177f);
  }
  void add_inner_ring_thickness(float inner_ring_thickness) {
    fbb_.AddElement<float>(CursorDef::VT_INNER_RING_THICKNESS, inner_ring_thickness, 0.14f);
  }
  void add_mid_ring_end(float mid_ring_end) {
    fbb_.AddElement<float>(CursorDef::VT_MID_RING_END, mid_ring_end, 0.177f);
  }
  void add_mid_ring_opacity(float mid_ring_opacity) {
    fbb_.AddElement<float>(CursorDef::VT_MID_RING_OPACITY, mid_ring_opacity, 0.22f);
  }
  void add_device(DeviceType device) {
    fbb_.AddElement<int32_t>(CursorDef::VT_DEVICE, static_cast<int32_t>(device), 3);
  }
  explicit CursorDefBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CursorDefBuilder &operator=(const CursorDefBuilder &);
  flatbuffers::Offset<CursorDef> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CursorDef>(end);
    return o;
  }
};

inline flatbuffers::Offset<CursorDef> CreateCursorDef(
    flatbuffers::FlatBufferBuilder &_fbb,
    float ring_active_diameter = 1.0f,
    float ring_inactive_diameter = 1.0f,
    const Color *hit_color = 0,
    const Color *no_hit_color = 0,
    float no_hit_distance = 2.0f,
    float inner_hole = 0.0f,
    float inner_ring_end = 0.177f,
    float inner_ring_thickness = 0.14f,
    float mid_ring_end = 0.177f,
    float mid_ring_opacity = 0.22f,
    DeviceType device = DeviceType_Controller) {
  CursorDefBuilder builder_(_fbb);
  builder_.add_device(device);
  builder_.add_mid_ring_opacity(mid_ring_opacity);
  builder_.add_mid_ring_end(mid_ring_end);
  builder_.add_inner_ring_thickness(inner_ring_thickness);
  builder_.add_inner_ring_end(inner_ring_end);
  builder_.add_inner_hole(inner_hole);
  builder_.add_no_hit_distance(no_hit_distance);
  builder_.add_no_hit_color(no_hit_color);
  builder_.add_hit_color(hit_color);
  builder_.add_ring_inactive_diameter(ring_inactive_diameter);
  builder_.add_ring_active_diameter(ring_active_diameter);
  return builder_.Finish();
}

inline const lull::CursorDef *GetCursorDef(const void *buf) {
  return flatbuffers::GetRoot<lull::CursorDef>(buf);
}

inline bool VerifyCursorDefBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<lull::CursorDef>(nullptr);
}

inline void FinishCursorDefBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<lull::CursorDef> root) {
  fbb.Finish(root);
}

}  // namespace lull

#endif  // FLATBUFFERS_GENERATED_CURSORDEF_LULL_H_
