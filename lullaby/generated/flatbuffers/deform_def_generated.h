// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_DEFORMDEF_LULL_H_
#define FLATBUFFERS_GENERATED_DEFORMDEF_LULL_H_

#include "flatbuffers/flatbuffers.h"

#include "common_generated.h"

namespace lull {

struct DeformedDef;

struct DeformerDef;

struct WaypointPath;

struct Waypoint;

enum DeformMode {
  DeformMode_None = 0  /// Objects will be wrapped around a cylinder centered at world space 0,0,0
,
  DeformMode_GlobalCylinder = 1  /// Objects will be bent based on their x and z distance from 0,0,0 in the
  /// Deformer's space.  The bend will be calculated as a cylinder wrap, with
  /// the cylinder centered at (0,0,horizontal_radius) in the Deformer's space.
,
  DeformMode_CylinderBend = 2  /// Objects will be bent based on a set of input and output points.
,
  DeformMode_Waypoint = 3,
  DeformMode_MIN = DeformMode_None,
  DeformMode_MAX = DeformMode_Waypoint
};

inline DeformMode (&EnumValuesDeformMode())[4] {
  static DeformMode values[] = {
    DeformMode_None,
    DeformMode_GlobalCylinder,
    DeformMode_CylinderBend,
    DeformMode_Waypoint
  };
  return values;
}

inline const char **EnumNamesDeformMode() {
  static const char *names[] = {
    "None",
    "GlobalCylinder",
    "CylinderBend",
    "Waypoint",
    nullptr
  };
  return names;
}

inline const char *EnumNameDeformMode(DeformMode e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesDeformMode()[index];
}

/// Any object that is being deformed by some other object up the stack will
/// need this def.  When *DeformedDef* is specified, the entity applies the
/// DeformerDef settings used by its parent.  If its parent doesn't have a
/// DeformedDef or a DeformerDef, it will not deform.
struct DeformedDef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.DeformedDef";
  }
  enum {
    VT_WAYPOINT_PATH_ID = 4
  };
  /// Used in the waypoint deformation mode to select which waypoint path that
  /// should apply to this deformed entity.
  const flatbuffers::String *waypoint_path_id() const {
    return GetPointer<const flatbuffers::String *>(VT_WAYPOINT_PATH_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_WAYPOINT_PATH_ID) &&
           verifier.Verify(waypoint_path_id()) &&
           verifier.EndTable();
  }
};

struct DeformedDefBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_waypoint_path_id(flatbuffers::Offset<flatbuffers::String> waypoint_path_id) {
    fbb_.AddOffset(DeformedDef::VT_WAYPOINT_PATH_ID, waypoint_path_id);
  }
  explicit DeformedDefBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DeformedDefBuilder &operator=(const DeformedDefBuilder &);
  flatbuffers::Offset<DeformedDef> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DeformedDef>(end);
    return o;
  }
};

inline flatbuffers::Offset<DeformedDef> CreateDeformedDef(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> waypoint_path_id = 0) {
  DeformedDefBuilder builder_(_fbb);
  builder_.add_waypoint_path_id(waypoint_path_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<DeformedDef> CreateDeformedDefDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *waypoint_path_id = nullptr) {
  return lull::CreateDeformedDef(
      _fbb,
      waypoint_path_id ? _fbb.CreateString(waypoint_path_id) : 0);
}

/// Uses the DeformSystem to apply a cylindrical deformation to the entity. This
/// has the effect of bending it around the user.
/// Equivalent to a DeformDef with is_inherited set to true
struct DeformerDef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.DeformerDef";
  }
  enum {
    VT_DEFORM_MODE = 4,
    VT_HORIZONTAL_RADIUS = 6,
    VT_CLAMP_ANGLE = 8,
    VT_WAYPOINT_PATHS = 10
  };
  DeformMode deform_mode() const {
    return static_cast<DeformMode>(GetField<int32_t>(VT_DEFORM_MODE, 2));
  }
  /// The radius of the cylinder to deform around (centered on the user).
  float horizontal_radius() const {
    return GetField<float>(VT_HORIZONTAL_RADIUS, 0.0f);
  }
  /// The angle at which a deformation around the Deformer will be clamped. This
  /// is equivalent to clamping a deformed entity's x position in the range
  /// [-clamp_angle * radius, clamp_angle * radius]. This only applies the
  /// CylinderBend deform mode, and negative values or 0.0 will indicate no
  /// clamping.
  float clamp_angle() const {
    return GetField<float>(VT_CLAMP_ANGLE, 0.0f);
  }
  /// The paths along which the Watpoint deformation mode will deform entities.
  const flatbuffers::Vector<flatbuffers::Offset<WaypointPath>> *waypoint_paths() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<WaypointPath>> *>(VT_WAYPOINT_PATHS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_DEFORM_MODE) &&
           VerifyField<float>(verifier, VT_HORIZONTAL_RADIUS) &&
           VerifyField<float>(verifier, VT_CLAMP_ANGLE) &&
           VerifyOffset(verifier, VT_WAYPOINT_PATHS) &&
           verifier.Verify(waypoint_paths()) &&
           verifier.VerifyVectorOfTables(waypoint_paths()) &&
           verifier.EndTable();
  }
};

struct DeformerDefBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_deform_mode(DeformMode deform_mode) {
    fbb_.AddElement<int32_t>(DeformerDef::VT_DEFORM_MODE, static_cast<int32_t>(deform_mode), 2);
  }
  void add_horizontal_radius(float horizontal_radius) {
    fbb_.AddElement<float>(DeformerDef::VT_HORIZONTAL_RADIUS, horizontal_radius, 0.0f);
  }
  void add_clamp_angle(float clamp_angle) {
    fbb_.AddElement<float>(DeformerDef::VT_CLAMP_ANGLE, clamp_angle, 0.0f);
  }
  void add_waypoint_paths(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<WaypointPath>>> waypoint_paths) {
    fbb_.AddOffset(DeformerDef::VT_WAYPOINT_PATHS, waypoint_paths);
  }
  explicit DeformerDefBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DeformerDefBuilder &operator=(const DeformerDefBuilder &);
  flatbuffers::Offset<DeformerDef> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DeformerDef>(end);
    return o;
  }
};

inline flatbuffers::Offset<DeformerDef> CreateDeformerDef(
    flatbuffers::FlatBufferBuilder &_fbb,
    DeformMode deform_mode = DeformMode_CylinderBend,
    float horizontal_radius = 0.0f,
    float clamp_angle = 0.0f,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<WaypointPath>>> waypoint_paths = 0) {
  DeformerDefBuilder builder_(_fbb);
  builder_.add_waypoint_paths(waypoint_paths);
  builder_.add_clamp_angle(clamp_angle);
  builder_.add_horizontal_radius(horizontal_radius);
  builder_.add_deform_mode(deform_mode);
  return builder_.Finish();
}

inline flatbuffers::Offset<DeformerDef> CreateDeformerDefDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    DeformMode deform_mode = DeformMode_CylinderBend,
    float horizontal_radius = 0.0f,
    float clamp_angle = 0.0f,
    const std::vector<flatbuffers::Offset<WaypointPath>> *waypoint_paths = nullptr) {
  return lull::CreateDeformerDef(
      _fbb,
      deform_mode,
      horizontal_radius,
      clamp_angle,
      waypoint_paths ? _fbb.CreateVector<flatbuffers::Offset<WaypointPath>>(*waypoint_paths) : 0);
}

struct WaypointPath FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.WaypointPath";
  }
  enum {
    VT_PATH_ID = 4,
    VT_WAYPOINTS = 6,
    VT_USE_AABB_ANCHOR = 8
  };
  /// Optional identifier for this path. If specified this path will only apply
  /// to Deformed entities with the matching path_id.
  const flatbuffers::String *path_id() const {
    return GetPointer<const flatbuffers::String *>(VT_PATH_ID);
  }
  /// A list of nodes for mapping original positions and rotations to their new
  /// deformations. The list should be internally ordered by the axis of
  /// interest of the original_position node.
  const flatbuffers::Vector<flatbuffers::Offset<Waypoint>> *waypoints() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Waypoint>> *>(VT_WAYPOINTS);
  }
  /// By default, this is false and we match the waypoints with the Deformed's
  /// entity's position.
  /// If this is true, match with a point within the Deformed's aabb instead.
  bool use_aabb_anchor() const {
    return GetField<uint8_t>(VT_USE_AABB_ANCHOR, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PATH_ID) &&
           verifier.Verify(path_id()) &&
           VerifyOffset(verifier, VT_WAYPOINTS) &&
           verifier.Verify(waypoints()) &&
           verifier.VerifyVectorOfTables(waypoints()) &&
           VerifyField<uint8_t>(verifier, VT_USE_AABB_ANCHOR) &&
           verifier.EndTable();
  }
};

struct WaypointPathBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_path_id(flatbuffers::Offset<flatbuffers::String> path_id) {
    fbb_.AddOffset(WaypointPath::VT_PATH_ID, path_id);
  }
  void add_waypoints(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Waypoint>>> waypoints) {
    fbb_.AddOffset(WaypointPath::VT_WAYPOINTS, waypoints);
  }
  void add_use_aabb_anchor(bool use_aabb_anchor) {
    fbb_.AddElement<uint8_t>(WaypointPath::VT_USE_AABB_ANCHOR, static_cast<uint8_t>(use_aabb_anchor), 0);
  }
  explicit WaypointPathBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WaypointPathBuilder &operator=(const WaypointPathBuilder &);
  flatbuffers::Offset<WaypointPath> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WaypointPath>(end);
    return o;
  }
};

inline flatbuffers::Offset<WaypointPath> CreateWaypointPath(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> path_id = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Waypoint>>> waypoints = 0,
    bool use_aabb_anchor = false) {
  WaypointPathBuilder builder_(_fbb);
  builder_.add_waypoints(waypoints);
  builder_.add_path_id(path_id);
  builder_.add_use_aabb_anchor(use_aabb_anchor);
  return builder_.Finish();
}

inline flatbuffers::Offset<WaypointPath> CreateWaypointPathDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *path_id = nullptr,
    const std::vector<flatbuffers::Offset<Waypoint>> *waypoints = nullptr,
    bool use_aabb_anchor = false) {
  return lull::CreateWaypointPath(
      _fbb,
      path_id ? _fbb.CreateString(path_id) : 0,
      waypoints ? _fbb.CreateVector<flatbuffers::Offset<Waypoint>>(*waypoints) : 0,
      use_aabb_anchor);
}

struct Waypoint FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.Waypoint";
  }
  enum {
    VT_ORIGINAL_POSITION = 4,
    VT_REMAPPED_POSITION = 6,
    VT_REMAPPED_ROTATION = 8,
    VT_ORIGINAL_AABB_ANCHOR = 10,
    VT_REMAPPED_AABB_ANCHOR = 12
  };
  /// The xyz position in space used as the original reference point to
  /// to match against in Waypoint deformations. Should be local to the
  /// deformer's coordinate system.
  const Vec3 *original_position() const {
    return GetStruct<const Vec3 *>(VT_ORIGINAL_POSITION);
  }
  /// The xyz position in space used as the new position in space in
  /// Waypoint deformations.
  const Vec3 *remapped_position() const {
    return GetStruct<const Vec3 *>(VT_REMAPPED_POSITION);
  }
  /// The Euler angle used as the new mapping in Waypoint deformations.
  const Vec3 *remapped_rotation() const {
    return GetStruct<const Vec3 *>(VT_REMAPPED_ROTATION);
  }
  /// Normalized coordinates representing a point in the Deformed's aabb that
  /// will match with |original_position|. (0,0,0) is the left, bottom, far
  /// corner, and (1,1,1) is the right, top, near corner.
  /// Ignored if |use_aabb_anchor| is false.
  const Vec3 *original_aabb_anchor() const {
    return GetStruct<const Vec3 *>(VT_ORIGINAL_AABB_ANCHOR);
  }
  /// Normalized coordinates representing a point in the Deformed's aabb that
  /// will match with |remapped_position|. (0,0,0) is the left, bottom, far
  /// corner, and (1,1,1) is the right, top, near corner.
  /// Ignored if |use_aabb_anchor| is false
  const Vec3 *remapped_aabb_anchor() const {
    return GetStruct<const Vec3 *>(VT_REMAPPED_AABB_ANCHOR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Vec3>(verifier, VT_ORIGINAL_POSITION) &&
           VerifyField<Vec3>(verifier, VT_REMAPPED_POSITION) &&
           VerifyField<Vec3>(verifier, VT_REMAPPED_ROTATION) &&
           VerifyField<Vec3>(verifier, VT_ORIGINAL_AABB_ANCHOR) &&
           VerifyField<Vec3>(verifier, VT_REMAPPED_AABB_ANCHOR) &&
           verifier.EndTable();
  }
};

struct WaypointBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_original_position(const Vec3 *original_position) {
    fbb_.AddStruct(Waypoint::VT_ORIGINAL_POSITION, original_position);
  }
  void add_remapped_position(const Vec3 *remapped_position) {
    fbb_.AddStruct(Waypoint::VT_REMAPPED_POSITION, remapped_position);
  }
  void add_remapped_rotation(const Vec3 *remapped_rotation) {
    fbb_.AddStruct(Waypoint::VT_REMAPPED_ROTATION, remapped_rotation);
  }
  void add_original_aabb_anchor(const Vec3 *original_aabb_anchor) {
    fbb_.AddStruct(Waypoint::VT_ORIGINAL_AABB_ANCHOR, original_aabb_anchor);
  }
  void add_remapped_aabb_anchor(const Vec3 *remapped_aabb_anchor) {
    fbb_.AddStruct(Waypoint::VT_REMAPPED_AABB_ANCHOR, remapped_aabb_anchor);
  }
  explicit WaypointBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WaypointBuilder &operator=(const WaypointBuilder &);
  flatbuffers::Offset<Waypoint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Waypoint>(end);
    return o;
  }
};

inline flatbuffers::Offset<Waypoint> CreateWaypoint(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Vec3 *original_position = 0,
    const Vec3 *remapped_position = 0,
    const Vec3 *remapped_rotation = 0,
    const Vec3 *original_aabb_anchor = 0,
    const Vec3 *remapped_aabb_anchor = 0) {
  WaypointBuilder builder_(_fbb);
  builder_.add_remapped_aabb_anchor(remapped_aabb_anchor);
  builder_.add_original_aabb_anchor(original_aabb_anchor);
  builder_.add_remapped_rotation(remapped_rotation);
  builder_.add_remapped_position(remapped_position);
  builder_.add_original_position(original_position);
  return builder_.Finish();
}

inline const lull::DeformerDef *GetDeformerDef(const void *buf) {
  return flatbuffers::GetRoot<lull::DeformerDef>(buf);
}

inline bool VerifyDeformerDefBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<lull::DeformerDef>(nullptr);
}

inline void FinishDeformerDefBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<lull::DeformerDef> root) {
  fbb.Finish(root);
}

}  // namespace lull

#endif  // FLATBUFFERS_GENERATED_DEFORMDEF_LULL_H_
