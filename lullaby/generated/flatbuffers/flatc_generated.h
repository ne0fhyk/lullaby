// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_FLATC_LULL_H_
#define FLATBUFFERS_GENERATED_FLATC_LULL_H_

#include "flatbuffers/flatbuffers.h"

namespace lull {

struct Vec2;

struct Vec3;

struct Vec4;

struct Quat;

struct DataBool;

struct DataInt;

struct DataFloat;

struct DataHashValue;

struct DataString;

struct DataVec2;

struct DataVec3;

struct DataVec4;

struct DataQuat;

struct InnerFixed;

struct MiddleFixed;

struct OuterFixed;

struct Basics;

struct Complex;

enum VariantDef {
  VariantDef_NONE = 0,
  VariantDef_DataBool = 1,
  VariantDef_DataInt = 2,
  VariantDef_DataFloat = 3,
  VariantDef_DataString = 4,
  VariantDef_DataHashValue = 5,
  VariantDef_DataVec2 = 6,
  VariantDef_DataVec3 = 7,
  VariantDef_DataVec4 = 8,
  VariantDef_DataQuat = 9,
  VariantDef_MIN = VariantDef_NONE,
  VariantDef_MAX = VariantDef_DataQuat
};

inline VariantDef (&EnumValuesVariantDef())[10] {
  static VariantDef values[] = {
    VariantDef_NONE,
    VariantDef_DataBool,
    VariantDef_DataInt,
    VariantDef_DataFloat,
    VariantDef_DataString,
    VariantDef_DataHashValue,
    VariantDef_DataVec2,
    VariantDef_DataVec3,
    VariantDef_DataVec4,
    VariantDef_DataQuat
  };
  return values;
}

inline const char **EnumNamesVariantDef() {
  static const char *names[] = {
    "NONE",
    "DataBool",
    "DataInt",
    "DataFloat",
    "DataString",
    "DataHashValue",
    "DataVec2",
    "DataVec3",
    "DataVec4",
    "DataQuat",
    nullptr
  };
  return names;
}

inline const char *EnumNameVariantDef(VariantDef e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesVariantDef()[index];
}

template<typename T> struct VariantDefTraits {
  static const VariantDef enum_value = VariantDef_NONE;
};

template<> struct VariantDefTraits<DataBool> {
  static const VariantDef enum_value = VariantDef_DataBool;
};

template<> struct VariantDefTraits<DataInt> {
  static const VariantDef enum_value = VariantDef_DataInt;
};

template<> struct VariantDefTraits<DataFloat> {
  static const VariantDef enum_value = VariantDef_DataFloat;
};

template<> struct VariantDefTraits<DataString> {
  static const VariantDef enum_value = VariantDef_DataString;
};

template<> struct VariantDefTraits<DataHashValue> {
  static const VariantDef enum_value = VariantDef_DataHashValue;
};

template<> struct VariantDefTraits<DataVec2> {
  static const VariantDef enum_value = VariantDef_DataVec2;
};

template<> struct VariantDefTraits<DataVec3> {
  static const VariantDef enum_value = VariantDef_DataVec3;
};

template<> struct VariantDefTraits<DataVec4> {
  static const VariantDef enum_value = VariantDef_DataVec4;
};

template<> struct VariantDefTraits<DataQuat> {
  static const VariantDef enum_value = VariantDef_DataQuat;
};

bool VerifyVariantDef(flatbuffers::Verifier &verifier, const void *obj, VariantDef type);
bool VerifyVariantDefVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum Day {
  Day_Monday = 0,
  Day_Tuesday = 1,
  Day_Wednesday = 2,
  Day_Thursday = 3,
  Day_Friday = 4,
  Day_Saturday = 5,
  Day_Suday = 6,
  Day_MIN = Day_Monday,
  Day_MAX = Day_Suday
};

inline Day (&EnumValuesDay())[7] {
  static Day values[] = {
    Day_Monday,
    Day_Tuesday,
    Day_Wednesday,
    Day_Thursday,
    Day_Friday,
    Day_Saturday,
    Day_Suday
  };
  return values;
}

inline const char **EnumNamesDay() {
  static const char *names[] = {
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday",
    "Suday",
    nullptr
  };
  return names;
}

inline const char *EnumNameDay(Day e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesDay()[index];
}

enum Flags {
  Flags_High = 0,
  Flags_Medium = 1,
  Flags_Low = 2,
  Flags_MIN = Flags_High,
  Flags_MAX = Flags_Low
};

inline Flags (&EnumValuesFlags())[3] {
  static Flags values[] = {
    Flags_High,
    Flags_Medium,
    Flags_Low
  };
  return values;
}

inline const char **EnumNamesFlags() {
  static const char *names[] = {
    "High",
    "Medium",
    "Low",
    nullptr
  };
  return names;
}

inline const char *EnumNameFlags(Flags e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesFlags()[index];
}

enum BitFlags {
  BitFlags_High = 1,
  BitFlags_Medium = 2,
  BitFlags_Low = 4,
  BitFlags_NONE = 0,
  BitFlags_ANY = 7
};

inline BitFlags (&EnumValuesBitFlags())[3] {
  static BitFlags values[] = {
    BitFlags_High,
    BitFlags_Medium,
    BitFlags_Low
  };
  return values;
}

inline const char **EnumNamesBitFlags() {
  static const char *names[] = {
    "High",
    "Medium",
    "",
    "Low",
    nullptr
  };
  return names;
}

inline const char *EnumNameBitFlags(BitFlags e) {
  const size_t index = static_cast<int>(e) - static_cast<int>(BitFlags_High);
  return EnumNamesBitFlags()[index];
}

MANUALLY_ALIGNED_STRUCT(4) Vec2 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.Vec2";
  }
  Vec2() {
    memset(this, 0, sizeof(Vec2));
  }
  Vec2(const Vec2 &_o) {
    memcpy(this, &_o, sizeof(Vec2));
  }
  Vec2(float _x, float _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
STRUCT_END(Vec2, 8);

MANUALLY_ALIGNED_STRUCT(4) Vec3 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.Vec3";
  }
  Vec3() {
    memset(this, 0, sizeof(Vec3));
  }
  Vec3(const Vec3 &_o) {
    memcpy(this, &_o, sizeof(Vec3));
  }
  Vec3(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
STRUCT_END(Vec3, 12);

MANUALLY_ALIGNED_STRUCT(4) Vec4 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float w_;

 public:
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.Vec4";
  }
  Vec4() {
    memset(this, 0, sizeof(Vec4));
  }
  Vec4(const Vec4 &_o) {
    memcpy(this, &_o, sizeof(Vec4));
  }
  Vec4(float _x, float _y, float _z, float _w)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)),
        w_(flatbuffers::EndianScalar(_w)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
  float w() const {
    return flatbuffers::EndianScalar(w_);
  }
};
STRUCT_END(Vec4, 16);

MANUALLY_ALIGNED_STRUCT(4) Quat FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float w_;

 public:
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.Quat";
  }
  Quat() {
    memset(this, 0, sizeof(Quat));
  }
  Quat(const Quat &_o) {
    memcpy(this, &_o, sizeof(Quat));
  }
  Quat(float _x, float _y, float _z, float _w)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)),
        w_(flatbuffers::EndianScalar(_w)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
  float w() const {
    return flatbuffers::EndianScalar(w_);
  }
};
STRUCT_END(Quat, 16);

MANUALLY_ALIGNED_STRUCT(4) InnerFixed FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t a_;
  int32_t b_;
  int32_t c_;

 public:
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.InnerFixed";
  }
  InnerFixed() {
    memset(this, 0, sizeof(InnerFixed));
  }
  InnerFixed(const InnerFixed &_o) {
    memcpy(this, &_o, sizeof(InnerFixed));
  }
  InnerFixed(int32_t _a, int32_t _b, int32_t _c)
      : a_(flatbuffers::EndianScalar(_a)),
        b_(flatbuffers::EndianScalar(_b)),
        c_(flatbuffers::EndianScalar(_c)) {
  }
  int32_t a() const {
    return flatbuffers::EndianScalar(a_);
  }
  int32_t b() const {
    return flatbuffers::EndianScalar(b_);
  }
  int32_t c() const {
    return flatbuffers::EndianScalar(c_);
  }
};
STRUCT_END(InnerFixed, 12);

MANUALLY_ALIGNED_STRUCT(4) MiddleFixed FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t t_;
  InnerFixed in_;
  int32_t u_;
  int32_t v_;

 public:
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.MiddleFixed";
  }
  MiddleFixed() {
    memset(this, 0, sizeof(MiddleFixed));
  }
  MiddleFixed(const MiddleFixed &_o) {
    memcpy(this, &_o, sizeof(MiddleFixed));
  }
  MiddleFixed(int32_t _t, const InnerFixed &_in, int32_t _u, int32_t _v)
      : t_(flatbuffers::EndianScalar(_t)),
        in_(_in),
        u_(flatbuffers::EndianScalar(_u)),
        v_(flatbuffers::EndianScalar(_v)) {
  }
  int32_t t() const {
    return flatbuffers::EndianScalar(t_);
  }
  const InnerFixed &in() const {
    return in_;
  }
  int32_t u() const {
    return flatbuffers::EndianScalar(u_);
  }
  int32_t v() const {
    return flatbuffers::EndianScalar(v_);
  }
};
STRUCT_END(MiddleFixed, 24);

MANUALLY_ALIGNED_STRUCT(4) OuterFixed FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  MiddleFixed mid_;
  float y_;
  float z_;

 public:
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.OuterFixed";
  }
  OuterFixed() {
    memset(this, 0, sizeof(OuterFixed));
  }
  OuterFixed(const OuterFixed &_o) {
    memcpy(this, &_o, sizeof(OuterFixed));
  }
  OuterFixed(float _x, const MiddleFixed &_mid, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        mid_(_mid),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  const MiddleFixed &mid() const {
    return mid_;
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
STRUCT_END(OuterFixed, 36);

struct DataBool FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.DataBool";
  }
  enum {
    VT_VALUE = 4
  };
  bool value() const {
    return GetField<uint8_t>(VT_VALUE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct DataBoolBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(bool value) {
    fbb_.AddElement<uint8_t>(DataBool::VT_VALUE, static_cast<uint8_t>(value), 0);
  }
  explicit DataBoolBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DataBoolBuilder &operator=(const DataBoolBuilder &);
  flatbuffers::Offset<DataBool> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DataBool>(end);
    return o;
  }
};

inline flatbuffers::Offset<DataBool> CreateDataBool(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool value = false) {
  DataBoolBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct DataInt FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.DataInt";
  }
  enum {
    VT_VALUE = 4
  };
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct DataIntBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(DataInt::VT_VALUE, value, 0);
  }
  explicit DataIntBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DataIntBuilder &operator=(const DataIntBuilder &);
  flatbuffers::Offset<DataInt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DataInt>(end);
    return o;
  }
};

inline flatbuffers::Offset<DataInt> CreateDataInt(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t value = 0) {
  DataIntBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct DataFloat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.DataFloat";
  }
  enum {
    VT_VALUE = 4
  };
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct DataFloatBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(float value) {
    fbb_.AddElement<float>(DataFloat::VT_VALUE, value, 0.0f);
  }
  explicit DataFloatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DataFloatBuilder &operator=(const DataFloatBuilder &);
  flatbuffers::Offset<DataFloat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DataFloat>(end);
    return o;
  }
};

inline flatbuffers::Offset<DataFloat> CreateDataFloat(
    flatbuffers::FlatBufferBuilder &_fbb,
    float value = 0.0f) {
  DataFloatBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct DataHashValue FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.DataHashValue";
  }
  enum {
    VT_VALUE = 4
  };
  const flatbuffers::String *value() const {
    return GetPointer<const flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.Verify(value()) &&
           verifier.EndTable();
  }
};

struct DataHashValueBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::String> value) {
    fbb_.AddOffset(DataHashValue::VT_VALUE, value);
  }
  explicit DataHashValueBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DataHashValueBuilder &operator=(const DataHashValueBuilder &);
  flatbuffers::Offset<DataHashValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DataHashValue>(end);
    return o;
  }
};

inline flatbuffers::Offset<DataHashValue> CreateDataHashValue(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> value = 0) {
  DataHashValueBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<DataHashValue> CreateDataHashValueDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *value = nullptr) {
  return lull::CreateDataHashValue(
      _fbb,
      value ? _fbb.CreateString(value) : 0);
}

struct DataString FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.DataString";
  }
  enum {
    VT_VALUE = 4
  };
  const flatbuffers::String *value() const {
    return GetPointer<const flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.Verify(value()) &&
           verifier.EndTable();
  }
};

struct DataStringBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::String> value) {
    fbb_.AddOffset(DataString::VT_VALUE, value);
  }
  explicit DataStringBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DataStringBuilder &operator=(const DataStringBuilder &);
  flatbuffers::Offset<DataString> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DataString>(end);
    return o;
  }
};

inline flatbuffers::Offset<DataString> CreateDataString(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> value = 0) {
  DataStringBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<DataString> CreateDataStringDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *value = nullptr) {
  return lull::CreateDataString(
      _fbb,
      value ? _fbb.CreateString(value) : 0);
}

struct DataVec2 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.DataVec2";
  }
  enum {
    VT_VALUE = 4
  };
  const Vec2 *value() const {
    return GetStruct<const Vec2 *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Vec2>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct DataVec2Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(const Vec2 *value) {
    fbb_.AddStruct(DataVec2::VT_VALUE, value);
  }
  explicit DataVec2Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DataVec2Builder &operator=(const DataVec2Builder &);
  flatbuffers::Offset<DataVec2> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DataVec2>(end);
    return o;
  }
};

inline flatbuffers::Offset<DataVec2> CreateDataVec2(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Vec2 *value = 0) {
  DataVec2Builder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct DataVec3 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.DataVec3";
  }
  enum {
    VT_VALUE = 4
  };
  const Vec3 *value() const {
    return GetStruct<const Vec3 *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Vec3>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct DataVec3Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(const Vec3 *value) {
    fbb_.AddStruct(DataVec3::VT_VALUE, value);
  }
  explicit DataVec3Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DataVec3Builder &operator=(const DataVec3Builder &);
  flatbuffers::Offset<DataVec3> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DataVec3>(end);
    return o;
  }
};

inline flatbuffers::Offset<DataVec3> CreateDataVec3(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Vec3 *value = 0) {
  DataVec3Builder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct DataVec4 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.DataVec4";
  }
  enum {
    VT_VALUE = 4
  };
  const Vec4 *value() const {
    return GetStruct<const Vec4 *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Vec4>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct DataVec4Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(const Vec4 *value) {
    fbb_.AddStruct(DataVec4::VT_VALUE, value);
  }
  explicit DataVec4Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DataVec4Builder &operator=(const DataVec4Builder &);
  flatbuffers::Offset<DataVec4> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DataVec4>(end);
    return o;
  }
};

inline flatbuffers::Offset<DataVec4> CreateDataVec4(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Vec4 *value = 0) {
  DataVec4Builder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct DataQuat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.DataQuat";
  }
  enum {
    VT_VALUE = 4
  };
  const Quat *value() const {
    return GetStruct<const Quat *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Quat>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct DataQuatBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(const Quat *value) {
    fbb_.AddStruct(DataQuat::VT_VALUE, value);
  }
  explicit DataQuatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DataQuatBuilder &operator=(const DataQuatBuilder &);
  flatbuffers::Offset<DataQuat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DataQuat>(end);
    return o;
  }
};

inline flatbuffers::Offset<DataQuat> CreateDataQuat(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Quat *value = 0) {
  DataQuatBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Basics FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.Basics";
  }
  enum {
    VT_B = 4,
    VT_U8 = 6,
    VT_I8 = 8,
    VT_U16 = 10,
    VT_I16 = 12,
    VT_U32 = 14,
    VT_I32 = 16,
    VT_U64 = 18,
    VT_I64 = 20,
    VT_R32 = 22,
    VT_R64 = 24,
    VT_STR = 26
  };
  bool b() const {
    return GetField<uint8_t>(VT_B, 0) != 0;
  }
  uint8_t u8() const {
    return GetField<uint8_t>(VT_U8, 0);
  }
  int8_t i8() const {
    return GetField<int8_t>(VT_I8, 0);
  }
  uint16_t u16() const {
    return GetField<uint16_t>(VT_U16, 0);
  }
  int16_t i16() const {
    return GetField<int16_t>(VT_I16, 0);
  }
  uint32_t u32() const {
    return GetField<uint32_t>(VT_U32, 0);
  }
  int32_t i32() const {
    return GetField<int32_t>(VT_I32, 0);
  }
  uint64_t u64() const {
    return GetField<uint64_t>(VT_U64, 0);
  }
  int64_t i64() const {
    return GetField<int64_t>(VT_I64, 0);
  }
  float r32() const {
    return GetField<float>(VT_R32, 0.0f);
  }
  double r64() const {
    return GetField<double>(VT_R64, 0.0);
  }
  const flatbuffers::String *str() const {
    return GetPointer<const flatbuffers::String *>(VT_STR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_B) &&
           VerifyField<uint8_t>(verifier, VT_U8) &&
           VerifyField<int8_t>(verifier, VT_I8) &&
           VerifyField<uint16_t>(verifier, VT_U16) &&
           VerifyField<int16_t>(verifier, VT_I16) &&
           VerifyField<uint32_t>(verifier, VT_U32) &&
           VerifyField<int32_t>(verifier, VT_I32) &&
           VerifyField<uint64_t>(verifier, VT_U64) &&
           VerifyField<int64_t>(verifier, VT_I64) &&
           VerifyField<float>(verifier, VT_R32) &&
           VerifyField<double>(verifier, VT_R64) &&
           VerifyOffset(verifier, VT_STR) &&
           verifier.Verify(str()) &&
           verifier.EndTable();
  }
};

struct BasicsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_b(bool b) {
    fbb_.AddElement<uint8_t>(Basics::VT_B, static_cast<uint8_t>(b), 0);
  }
  void add_u8(uint8_t u8) {
    fbb_.AddElement<uint8_t>(Basics::VT_U8, u8, 0);
  }
  void add_i8(int8_t i8) {
    fbb_.AddElement<int8_t>(Basics::VT_I8, i8, 0);
  }
  void add_u16(uint16_t u16) {
    fbb_.AddElement<uint16_t>(Basics::VT_U16, u16, 0);
  }
  void add_i16(int16_t i16) {
    fbb_.AddElement<int16_t>(Basics::VT_I16, i16, 0);
  }
  void add_u32(uint32_t u32) {
    fbb_.AddElement<uint32_t>(Basics::VT_U32, u32, 0);
  }
  void add_i32(int32_t i32) {
    fbb_.AddElement<int32_t>(Basics::VT_I32, i32, 0);
  }
  void add_u64(uint64_t u64) {
    fbb_.AddElement<uint64_t>(Basics::VT_U64, u64, 0);
  }
  void add_i64(int64_t i64) {
    fbb_.AddElement<int64_t>(Basics::VT_I64, i64, 0);
  }
  void add_r32(float r32) {
    fbb_.AddElement<float>(Basics::VT_R32, r32, 0.0f);
  }
  void add_r64(double r64) {
    fbb_.AddElement<double>(Basics::VT_R64, r64, 0.0);
  }
  void add_str(flatbuffers::Offset<flatbuffers::String> str) {
    fbb_.AddOffset(Basics::VT_STR, str);
  }
  explicit BasicsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BasicsBuilder &operator=(const BasicsBuilder &);
  flatbuffers::Offset<Basics> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Basics>(end);
    return o;
  }
};

inline flatbuffers::Offset<Basics> CreateBasics(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool b = false,
    uint8_t u8 = 0,
    int8_t i8 = 0,
    uint16_t u16 = 0,
    int16_t i16 = 0,
    uint32_t u32 = 0,
    int32_t i32 = 0,
    uint64_t u64 = 0,
    int64_t i64 = 0,
    float r32 = 0.0f,
    double r64 = 0.0,
    flatbuffers::Offset<flatbuffers::String> str = 0) {
  BasicsBuilder builder_(_fbb);
  builder_.add_r64(r64);
  builder_.add_i64(i64);
  builder_.add_u64(u64);
  builder_.add_str(str);
  builder_.add_r32(r32);
  builder_.add_i32(i32);
  builder_.add_u32(u32);
  builder_.add_i16(i16);
  builder_.add_u16(u16);
  builder_.add_i8(i8);
  builder_.add_u8(u8);
  builder_.add_b(b);
  return builder_.Finish();
}

inline flatbuffers::Offset<Basics> CreateBasicsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool b = false,
    uint8_t u8 = 0,
    int8_t i8 = 0,
    uint16_t u16 = 0,
    int16_t i16 = 0,
    uint32_t u32 = 0,
    int32_t i32 = 0,
    uint64_t u64 = 0,
    int64_t i64 = 0,
    float r32 = 0.0f,
    double r64 = 0.0,
    const char *str = nullptr) {
  return lull::CreateBasics(
      _fbb,
      b,
      u8,
      i8,
      u16,
      i16,
      u32,
      i32,
      u64,
      i64,
      r32,
      r64,
      str ? _fbb.CreateString(str) : 0);
}

struct Complex FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.Complex";
  }
  enum {
    VT_DAY = 4,
    VT_FLAG = 6,
    VT_BIT_FLAG = 8,
    VT_OUT = 10,
    VT_OUTS = 12,
    VT_NAME = 14,
    VT_NAMES = 16,
    VT_NUMBERS = 18,
    VT_BASIC = 20,
    VT_BASICS = 22,
    VT_VEC2 = 24,
    VT_VEC2S = 26,
    VT_VEC3 = 28,
    VT_VEC3S = 30,
    VT_VEC4 = 32,
    VT_VEC4S = 34,
    VT_QUAT = 36,
    VT_QUATS = 38,
    VT_VARIANT_TYPE = 40,
    VT_VARIANT = 42,
    VT_NULLABLE_STRUCT = 44,
    VT_NULLABLE_TABLE = 46,
    VT_NULLABLE_NATIVE = 48,
    VT_DYNAMIC_TABLE = 50
  };
  Day day() const {
    return static_cast<Day>(GetField<int8_t>(VT_DAY, 0));
  }
  Flags flag() const {
    return static_cast<Flags>(GetField<int8_t>(VT_FLAG, 0));
  }
  BitFlags bit_flag() const {
    return static_cast<BitFlags>(GetField<int8_t>(VT_BIT_FLAG, 0));
  }
  const OuterFixed *out() const {
    return GetStruct<const OuterFixed *>(VT_OUT);
  }
  const flatbuffers::Vector<const OuterFixed *> *outs() const {
    return GetPointer<const flatbuffers::Vector<const OuterFixed *> *>(VT_OUTS);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *names() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_NAMES);
  }
  const flatbuffers::Vector<int32_t> *numbers() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_NUMBERS);
  }
  const Basics *basic() const {
    return GetPointer<const Basics *>(VT_BASIC);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Basics>> *basics() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Basics>> *>(VT_BASICS);
  }
  const Vec2 *vec2() const {
    return GetStruct<const Vec2 *>(VT_VEC2);
  }
  const flatbuffers::Vector<const Vec2 *> *vec2s() const {
    return GetPointer<const flatbuffers::Vector<const Vec2 *> *>(VT_VEC2S);
  }
  const Vec3 *vec3() const {
    return GetStruct<const Vec3 *>(VT_VEC3);
  }
  const flatbuffers::Vector<const Vec3 *> *vec3s() const {
    return GetPointer<const flatbuffers::Vector<const Vec3 *> *>(VT_VEC3S);
  }
  const Vec4 *vec4() const {
    return GetStruct<const Vec4 *>(VT_VEC4);
  }
  const flatbuffers::Vector<const Vec4 *> *vec4s() const {
    return GetPointer<const flatbuffers::Vector<const Vec4 *> *>(VT_VEC4S);
  }
  const Quat *quat() const {
    return GetStruct<const Quat *>(VT_QUAT);
  }
  const flatbuffers::Vector<const Quat *> *quats() const {
    return GetPointer<const flatbuffers::Vector<const Quat *> *>(VT_QUATS);
  }
  VariantDef variant_type() const {
    return static_cast<VariantDef>(GetField<uint8_t>(VT_VARIANT_TYPE, 0));
  }
  const void *variant() const {
    return GetPointer<const void *>(VT_VARIANT);
  }
  template<typename T> const T *variant_as() const;
  const DataBool *variant_as_DataBool() const {
    return variant_type() == VariantDef_DataBool ? static_cast<const DataBool *>(variant()) : nullptr;
  }
  const DataInt *variant_as_DataInt() const {
    return variant_type() == VariantDef_DataInt ? static_cast<const DataInt *>(variant()) : nullptr;
  }
  const DataFloat *variant_as_DataFloat() const {
    return variant_type() == VariantDef_DataFloat ? static_cast<const DataFloat *>(variant()) : nullptr;
  }
  const DataString *variant_as_DataString() const {
    return variant_type() == VariantDef_DataString ? static_cast<const DataString *>(variant()) : nullptr;
  }
  const DataHashValue *variant_as_DataHashValue() const {
    return variant_type() == VariantDef_DataHashValue ? static_cast<const DataHashValue *>(variant()) : nullptr;
  }
  const DataVec2 *variant_as_DataVec2() const {
    return variant_type() == VariantDef_DataVec2 ? static_cast<const DataVec2 *>(variant()) : nullptr;
  }
  const DataVec3 *variant_as_DataVec3() const {
    return variant_type() == VariantDef_DataVec3 ? static_cast<const DataVec3 *>(variant()) : nullptr;
  }
  const DataVec4 *variant_as_DataVec4() const {
    return variant_type() == VariantDef_DataVec4 ? static_cast<const DataVec4 *>(variant()) : nullptr;
  }
  const DataQuat *variant_as_DataQuat() const {
    return variant_type() == VariantDef_DataQuat ? static_cast<const DataQuat *>(variant()) : nullptr;
  }
  const InnerFixed *nullable_struct() const {
    return GetStruct<const InnerFixed *>(VT_NULLABLE_STRUCT);
  }
  const Basics *nullable_table() const {
    return GetPointer<const Basics *>(VT_NULLABLE_TABLE);
  }
  const Vec2 *nullable_native() const {
    return GetStruct<const Vec2 *>(VT_NULLABLE_NATIVE);
  }
  const Complex *dynamic_table() const {
    return GetPointer<const Complex *>(VT_DYNAMIC_TABLE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_DAY) &&
           VerifyField<int8_t>(verifier, VT_FLAG) &&
           VerifyField<int8_t>(verifier, VT_BIT_FLAG) &&
           VerifyField<OuterFixed>(verifier, VT_OUT) &&
           VerifyOffset(verifier, VT_OUTS) &&
           verifier.Verify(outs()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyOffset(verifier, VT_NAMES) &&
           verifier.Verify(names()) &&
           verifier.VerifyVectorOfStrings(names()) &&
           VerifyOffset(verifier, VT_NUMBERS) &&
           verifier.Verify(numbers()) &&
           VerifyOffset(verifier, VT_BASIC) &&
           verifier.VerifyTable(basic()) &&
           VerifyOffset(verifier, VT_BASICS) &&
           verifier.Verify(basics()) &&
           verifier.VerifyVectorOfTables(basics()) &&
           VerifyField<Vec2>(verifier, VT_VEC2) &&
           VerifyOffset(verifier, VT_VEC2S) &&
           verifier.Verify(vec2s()) &&
           VerifyField<Vec3>(verifier, VT_VEC3) &&
           VerifyOffset(verifier, VT_VEC3S) &&
           verifier.Verify(vec3s()) &&
           VerifyField<Vec4>(verifier, VT_VEC4) &&
           VerifyOffset(verifier, VT_VEC4S) &&
           verifier.Verify(vec4s()) &&
           VerifyField<Quat>(verifier, VT_QUAT) &&
           VerifyOffset(verifier, VT_QUATS) &&
           verifier.Verify(quats()) &&
           VerifyField<uint8_t>(verifier, VT_VARIANT_TYPE) &&
           VerifyOffset(verifier, VT_VARIANT) &&
           VerifyVariantDef(verifier, variant(), variant_type()) &&
           VerifyField<InnerFixed>(verifier, VT_NULLABLE_STRUCT) &&
           VerifyOffset(verifier, VT_NULLABLE_TABLE) &&
           verifier.VerifyTable(nullable_table()) &&
           VerifyField<Vec2>(verifier, VT_NULLABLE_NATIVE) &&
           VerifyOffset(verifier, VT_DYNAMIC_TABLE) &&
           verifier.VerifyTable(dynamic_table()) &&
           verifier.EndTable();
  }
};

template<> inline const DataBool *Complex::variant_as<DataBool>() const {
  return variant_as_DataBool();
}

template<> inline const DataInt *Complex::variant_as<DataInt>() const {
  return variant_as_DataInt();
}

template<> inline const DataFloat *Complex::variant_as<DataFloat>() const {
  return variant_as_DataFloat();
}

template<> inline const DataString *Complex::variant_as<DataString>() const {
  return variant_as_DataString();
}

template<> inline const DataHashValue *Complex::variant_as<DataHashValue>() const {
  return variant_as_DataHashValue();
}

template<> inline const DataVec2 *Complex::variant_as<DataVec2>() const {
  return variant_as_DataVec2();
}

template<> inline const DataVec3 *Complex::variant_as<DataVec3>() const {
  return variant_as_DataVec3();
}

template<> inline const DataVec4 *Complex::variant_as<DataVec4>() const {
  return variant_as_DataVec4();
}

template<> inline const DataQuat *Complex::variant_as<DataQuat>() const {
  return variant_as_DataQuat();
}

struct ComplexBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_day(Day day) {
    fbb_.AddElement<int8_t>(Complex::VT_DAY, static_cast<int8_t>(day), 0);
  }
  void add_flag(Flags flag) {
    fbb_.AddElement<int8_t>(Complex::VT_FLAG, static_cast<int8_t>(flag), 0);
  }
  void add_bit_flag(BitFlags bit_flag) {
    fbb_.AddElement<int8_t>(Complex::VT_BIT_FLAG, static_cast<int8_t>(bit_flag), 0);
  }
  void add_out(const OuterFixed *out) {
    fbb_.AddStruct(Complex::VT_OUT, out);
  }
  void add_outs(flatbuffers::Offset<flatbuffers::Vector<const OuterFixed *>> outs) {
    fbb_.AddOffset(Complex::VT_OUTS, outs);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Complex::VT_NAME, name);
  }
  void add_names(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> names) {
    fbb_.AddOffset(Complex::VT_NAMES, names);
  }
  void add_numbers(flatbuffers::Offset<flatbuffers::Vector<int32_t>> numbers) {
    fbb_.AddOffset(Complex::VT_NUMBERS, numbers);
  }
  void add_basic(flatbuffers::Offset<Basics> basic) {
    fbb_.AddOffset(Complex::VT_BASIC, basic);
  }
  void add_basics(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Basics>>> basics) {
    fbb_.AddOffset(Complex::VT_BASICS, basics);
  }
  void add_vec2(const Vec2 *vec2) {
    fbb_.AddStruct(Complex::VT_VEC2, vec2);
  }
  void add_vec2s(flatbuffers::Offset<flatbuffers::Vector<const Vec2 *>> vec2s) {
    fbb_.AddOffset(Complex::VT_VEC2S, vec2s);
  }
  void add_vec3(const Vec3 *vec3) {
    fbb_.AddStruct(Complex::VT_VEC3, vec3);
  }
  void add_vec3s(flatbuffers::Offset<flatbuffers::Vector<const Vec3 *>> vec3s) {
    fbb_.AddOffset(Complex::VT_VEC3S, vec3s);
  }
  void add_vec4(const Vec4 *vec4) {
    fbb_.AddStruct(Complex::VT_VEC4, vec4);
  }
  void add_vec4s(flatbuffers::Offset<flatbuffers::Vector<const Vec4 *>> vec4s) {
    fbb_.AddOffset(Complex::VT_VEC4S, vec4s);
  }
  void add_quat(const Quat *quat) {
    fbb_.AddStruct(Complex::VT_QUAT, quat);
  }
  void add_quats(flatbuffers::Offset<flatbuffers::Vector<const Quat *>> quats) {
    fbb_.AddOffset(Complex::VT_QUATS, quats);
  }
  void add_variant_type(VariantDef variant_type) {
    fbb_.AddElement<uint8_t>(Complex::VT_VARIANT_TYPE, static_cast<uint8_t>(variant_type), 0);
  }
  void add_variant(flatbuffers::Offset<void> variant) {
    fbb_.AddOffset(Complex::VT_VARIANT, variant);
  }
  void add_nullable_struct(const InnerFixed *nullable_struct) {
    fbb_.AddStruct(Complex::VT_NULLABLE_STRUCT, nullable_struct);
  }
  void add_nullable_table(flatbuffers::Offset<Basics> nullable_table) {
    fbb_.AddOffset(Complex::VT_NULLABLE_TABLE, nullable_table);
  }
  void add_nullable_native(const Vec2 *nullable_native) {
    fbb_.AddStruct(Complex::VT_NULLABLE_NATIVE, nullable_native);
  }
  void add_dynamic_table(flatbuffers::Offset<Complex> dynamic_table) {
    fbb_.AddOffset(Complex::VT_DYNAMIC_TABLE, dynamic_table);
  }
  explicit ComplexBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ComplexBuilder &operator=(const ComplexBuilder &);
  flatbuffers::Offset<Complex> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Complex>(end);
    return o;
  }
};

inline flatbuffers::Offset<Complex> CreateComplex(
    flatbuffers::FlatBufferBuilder &_fbb,
    Day day = Day_Monday,
    Flags flag = Flags_High,
    BitFlags bit_flag = static_cast<BitFlags>(0),
    const OuterFixed *out = 0,
    flatbuffers::Offset<flatbuffers::Vector<const OuterFixed *>> outs = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> names = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> numbers = 0,
    flatbuffers::Offset<Basics> basic = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Basics>>> basics = 0,
    const Vec2 *vec2 = 0,
    flatbuffers::Offset<flatbuffers::Vector<const Vec2 *>> vec2s = 0,
    const Vec3 *vec3 = 0,
    flatbuffers::Offset<flatbuffers::Vector<const Vec3 *>> vec3s = 0,
    const Vec4 *vec4 = 0,
    flatbuffers::Offset<flatbuffers::Vector<const Vec4 *>> vec4s = 0,
    const Quat *quat = 0,
    flatbuffers::Offset<flatbuffers::Vector<const Quat *>> quats = 0,
    VariantDef variant_type = VariantDef_NONE,
    flatbuffers::Offset<void> variant = 0,
    const InnerFixed *nullable_struct = 0,
    flatbuffers::Offset<Basics> nullable_table = 0,
    const Vec2 *nullable_native = 0,
    flatbuffers::Offset<Complex> dynamic_table = 0) {
  ComplexBuilder builder_(_fbb);
  builder_.add_dynamic_table(dynamic_table);
  builder_.add_nullable_native(nullable_native);
  builder_.add_nullable_table(nullable_table);
  builder_.add_nullable_struct(nullable_struct);
  builder_.add_variant(variant);
  builder_.add_quats(quats);
  builder_.add_quat(quat);
  builder_.add_vec4s(vec4s);
  builder_.add_vec4(vec4);
  builder_.add_vec3s(vec3s);
  builder_.add_vec3(vec3);
  builder_.add_vec2s(vec2s);
  builder_.add_vec2(vec2);
  builder_.add_basics(basics);
  builder_.add_basic(basic);
  builder_.add_numbers(numbers);
  builder_.add_names(names);
  builder_.add_name(name);
  builder_.add_outs(outs);
  builder_.add_out(out);
  builder_.add_variant_type(variant_type);
  builder_.add_bit_flag(bit_flag);
  builder_.add_flag(flag);
  builder_.add_day(day);
  return builder_.Finish();
}

inline flatbuffers::Offset<Complex> CreateComplexDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    Day day = Day_Monday,
    Flags flag = Flags_High,
    BitFlags bit_flag = static_cast<BitFlags>(0),
    const OuterFixed *out = 0,
    const std::vector<const OuterFixed *> *outs = nullptr,
    const char *name = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *names = nullptr,
    const std::vector<int32_t> *numbers = nullptr,
    flatbuffers::Offset<Basics> basic = 0,
    const std::vector<flatbuffers::Offset<Basics>> *basics = nullptr,
    const Vec2 *vec2 = 0,
    const std::vector<const Vec2 *> *vec2s = nullptr,
    const Vec3 *vec3 = 0,
    const std::vector<const Vec3 *> *vec3s = nullptr,
    const Vec4 *vec4 = 0,
    const std::vector<const Vec4 *> *vec4s = nullptr,
    const Quat *quat = 0,
    const std::vector<const Quat *> *quats = nullptr,
    VariantDef variant_type = VariantDef_NONE,
    flatbuffers::Offset<void> variant = 0,
    const InnerFixed *nullable_struct = 0,
    flatbuffers::Offset<Basics> nullable_table = 0,
    const Vec2 *nullable_native = 0,
    flatbuffers::Offset<Complex> dynamic_table = 0) {
  return lull::CreateComplex(
      _fbb,
      day,
      flag,
      bit_flag,
      out,
      outs ? _fbb.CreateVector<const OuterFixed *>(*outs) : 0,
      name ? _fbb.CreateString(name) : 0,
      names ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*names) : 0,
      numbers ? _fbb.CreateVector<int32_t>(*numbers) : 0,
      basic,
      basics ? _fbb.CreateVector<flatbuffers::Offset<Basics>>(*basics) : 0,
      vec2,
      vec2s ? _fbb.CreateVector<const Vec2 *>(*vec2s) : 0,
      vec3,
      vec3s ? _fbb.CreateVector<const Vec3 *>(*vec3s) : 0,
      vec4,
      vec4s ? _fbb.CreateVector<const Vec4 *>(*vec4s) : 0,
      quat,
      quats ? _fbb.CreateVector<const Quat *>(*quats) : 0,
      variant_type,
      variant,
      nullable_struct,
      nullable_table,
      nullable_native,
      dynamic_table);
}

inline bool VerifyVariantDef(flatbuffers::Verifier &verifier, const void *obj, VariantDef type) {
  switch (type) {
    case VariantDef_NONE: {
      return true;
    }
    case VariantDef_DataBool: {
      auto ptr = reinterpret_cast<const DataBool *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VariantDef_DataInt: {
      auto ptr = reinterpret_cast<const DataInt *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VariantDef_DataFloat: {
      auto ptr = reinterpret_cast<const DataFloat *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VariantDef_DataString: {
      auto ptr = reinterpret_cast<const DataString *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VariantDef_DataHashValue: {
      auto ptr = reinterpret_cast<const DataHashValue *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VariantDef_DataVec2: {
      auto ptr = reinterpret_cast<const DataVec2 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VariantDef_DataVec3: {
      auto ptr = reinterpret_cast<const DataVec3 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VariantDef_DataVec4: {
      auto ptr = reinterpret_cast<const DataVec4 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VariantDef_DataQuat: {
      auto ptr = reinterpret_cast<const DataQuat *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyVariantDefVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyVariantDef(
        verifier,  values->Get(i), types->GetEnum<VariantDef>(i))) {
      return false;
    }
  }
  return true;
}

inline const lull::Complex *GetComplex(const void *buf) {
  return flatbuffers::GetRoot<lull::Complex>(buf);
}

inline const char *ComplexIdentifier() {
  return "DATA";
}

inline bool ComplexBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, ComplexIdentifier());
}

inline bool VerifyComplexBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<lull::Complex>(ComplexIdentifier());
}

inline void FinishComplexBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<lull::Complex> root) {
  fbb.Finish(root, ComplexIdentifier());
}

}  // namespace lull

#endif  // FLATBUFFERS_GENERATED_FLATC_LULL_H_