// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_LIGHTDEF_LULL_H_
#define FLATBUFFERS_GENERATED_LIGHTDEF_LULL_H_

#include "flatbuffers/flatbuffers.h"

#include "common_generated.h"

namespace lull {

struct AmbientLightDef;

struct DirectionalLightDef;

struct PointLightDef;

struct LightableDef;

/// Defines an ambient light source.
struct AmbientLightDef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.AmbientLightDef";
  }
  enum {
    VT_GROUP = 4,
    VT_COLOR = 6
  };
  /// The group of lights to which this light belongs.
  uint32_t group() const {
    return GetField<uint32_t>(VT_GROUP, 0);
  }
  /// The color of the ambient light.
  const lull::Color *color() const {
    return GetStruct<const lull::Color *>(VT_COLOR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_GROUP) &&
           VerifyField<lull::Color>(verifier, VT_COLOR) &&
           verifier.EndTable();
  }
};

struct AmbientLightDefBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_group(uint32_t group) {
    fbb_.AddElement<uint32_t>(AmbientLightDef::VT_GROUP, group, 0);
  }
  void add_color(const lull::Color *color) {
    fbb_.AddStruct(AmbientLightDef::VT_COLOR, color);
  }
  AmbientLightDefBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AmbientLightDefBuilder &operator=(const AmbientLightDefBuilder &);
  flatbuffers::Offset<AmbientLightDef> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<AmbientLightDef>(end);
    return o;
  }
};

inline flatbuffers::Offset<AmbientLightDef> CreateAmbientLightDef(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t group = 0,
    const lull::Color *color = 0) {
  AmbientLightDefBuilder builder_(_fbb);
  builder_.add_color(color);
  builder_.add_group(group);
  return builder_.Finish();
}

/// Defines a directional light source.
struct DirectionalLightDef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.DirectionalLightDef";
  }
  enum {
    VT_GROUP = 4,
    VT_COLOR = 6,
    VT_EXPONENT = 8,
    VT_ROTATION = 10
  };
  /// The group of lights to which this light belongs.
  uint32_t group() const {
    return GetField<uint32_t>(VT_GROUP, 0);
  }
  /// The color of the directional light.
  const lull::Color *color() const {
    return GetStruct<const lull::Color *>(VT_COLOR);
  }
  /// The intensity of the directional light specular width.
  float exponent() const {
    return GetField<float>(VT_EXPONENT, 0.0f);
  }
  const lull::Quat *rotation() const {
    return GetStruct<const lull::Quat *>(VT_ROTATION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_GROUP) &&
           VerifyField<lull::Color>(verifier, VT_COLOR) &&
           VerifyField<float>(verifier, VT_EXPONENT) &&
           VerifyField<lull::Quat>(verifier, VT_ROTATION) &&
           verifier.EndTable();
  }
};

struct DirectionalLightDefBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_group(uint32_t group) {
    fbb_.AddElement<uint32_t>(DirectionalLightDef::VT_GROUP, group, 0);
  }
  void add_color(const lull::Color *color) {
    fbb_.AddStruct(DirectionalLightDef::VT_COLOR, color);
  }
  void add_exponent(float exponent) {
    fbb_.AddElement<float>(DirectionalLightDef::VT_EXPONENT, exponent, 0.0f);
  }
  void add_rotation(const lull::Quat *rotation) {
    fbb_.AddStruct(DirectionalLightDef::VT_ROTATION, rotation);
  }
  DirectionalLightDefBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DirectionalLightDefBuilder &operator=(const DirectionalLightDefBuilder &);
  flatbuffers::Offset<DirectionalLightDef> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<DirectionalLightDef>(end);
    return o;
  }
};

inline flatbuffers::Offset<DirectionalLightDef> CreateDirectionalLightDef(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t group = 0,
    const lull::Color *color = 0,
    float exponent = 0.0f,
    const lull::Quat *rotation = 0) {
  DirectionalLightDefBuilder builder_(_fbb);
  builder_.add_rotation(rotation);
  builder_.add_exponent(exponent);
  builder_.add_color(color);
  builder_.add_group(group);
  return builder_.Finish();
}

/// Defines a point light source.
struct PointLightDef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.PointLightDef";
  }
  enum {
    VT_GROUP = 4,
    VT_COLOR = 6,
    VT_INTENSITY = 8,
    VT_EXPONENT = 10,
    VT_POSITION = 12
  };
  /// The group of lights to which this light belongs.
  uint32_t group() const {
    return GetField<uint32_t>(VT_GROUP, 0);
  }
  /// The color of the point light.
  const lull::Color *color() const {
    return GetStruct<const lull::Color *>(VT_COLOR);
  }
  /// The intensity of the point light.
  float intensity() const {
    return GetField<float>(VT_INTENSITY, 0.0f);
  }
  /// The intensity of the point light specular width.
  float exponent() const {
    return GetField<float>(VT_EXPONENT, 0.0f);
  }
  const lull::Vec3 *position() const {
    return GetStruct<const lull::Vec3 *>(VT_POSITION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_GROUP) &&
           VerifyField<lull::Color>(verifier, VT_COLOR) &&
           VerifyField<float>(verifier, VT_INTENSITY) &&
           VerifyField<float>(verifier, VT_EXPONENT) &&
           VerifyField<lull::Vec3>(verifier, VT_POSITION) &&
           verifier.EndTable();
  }
};

struct PointLightDefBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_group(uint32_t group) {
    fbb_.AddElement<uint32_t>(PointLightDef::VT_GROUP, group, 0);
  }
  void add_color(const lull::Color *color) {
    fbb_.AddStruct(PointLightDef::VT_COLOR, color);
  }
  void add_intensity(float intensity) {
    fbb_.AddElement<float>(PointLightDef::VT_INTENSITY, intensity, 0.0f);
  }
  void add_exponent(float exponent) {
    fbb_.AddElement<float>(PointLightDef::VT_EXPONENT, exponent, 0.0f);
  }
  void add_position(const lull::Vec3 *position) {
    fbb_.AddStruct(PointLightDef::VT_POSITION, position);
  }
  PointLightDefBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PointLightDefBuilder &operator=(const PointLightDefBuilder &);
  flatbuffers::Offset<PointLightDef> Finish() {
    const auto end = fbb_.EndTable(start_, 5);
    auto o = flatbuffers::Offset<PointLightDef>(end);
    return o;
  }
};

inline flatbuffers::Offset<PointLightDef> CreatePointLightDef(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t group = 0,
    const lull::Color *color = 0,
    float intensity = 0.0f,
    float exponent = 0.0f,
    const lull::Vec3 *position = 0) {
  PointLightDefBuilder builder_(_fbb);
  builder_.add_position(position);
  builder_.add_exponent(exponent);
  builder_.add_intensity(intensity);
  builder_.add_color(color);
  builder_.add_group(group);
  return builder_.Finish();
}

/// Defines an Entity that can be "lit" by the lights in the associated group.
struct LightableDef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.LightableDef";
  }
  enum {
    VT_GROUP = 4,
    VT_MAX_AMBIENT_LIGHTS = 6,
    VT_MAX_DIRECTIONAL_LIGHTS = 8,
    VT_MAX_POINT_LIGHTS = 10
  };
  /// The group of lights that will be applied to this Entity.
  uint32_t group() const {
    return GetField<uint32_t>(VT_GROUP, 0);
  }
  /// The maximum number of ambient lights to apply to this Entity.
  int32_t max_ambient_lights() const {
    return GetField<int32_t>(VT_MAX_AMBIENT_LIGHTS, 0);
  }
  /// The maximum number of directional lights to apply to this Entity.
  int32_t max_directional_lights() const {
    return GetField<int32_t>(VT_MAX_DIRECTIONAL_LIGHTS, 0);
  }
  /// The maximum number of point lights to apply to this Entity.
  int32_t max_point_lights() const {
    return GetField<int32_t>(VT_MAX_POINT_LIGHTS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_GROUP) &&
           VerifyField<int32_t>(verifier, VT_MAX_AMBIENT_LIGHTS) &&
           VerifyField<int32_t>(verifier, VT_MAX_DIRECTIONAL_LIGHTS) &&
           VerifyField<int32_t>(verifier, VT_MAX_POINT_LIGHTS) &&
           verifier.EndTable();
  }
};

struct LightableDefBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_group(uint32_t group) {
    fbb_.AddElement<uint32_t>(LightableDef::VT_GROUP, group, 0);
  }
  void add_max_ambient_lights(int32_t max_ambient_lights) {
    fbb_.AddElement<int32_t>(LightableDef::VT_MAX_AMBIENT_LIGHTS, max_ambient_lights, 0);
  }
  void add_max_directional_lights(int32_t max_directional_lights) {
    fbb_.AddElement<int32_t>(LightableDef::VT_MAX_DIRECTIONAL_LIGHTS, max_directional_lights, 0);
  }
  void add_max_point_lights(int32_t max_point_lights) {
    fbb_.AddElement<int32_t>(LightableDef::VT_MAX_POINT_LIGHTS, max_point_lights, 0);
  }
  LightableDefBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LightableDefBuilder &operator=(const LightableDefBuilder &);
  flatbuffers::Offset<LightableDef> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<LightableDef>(end);
    return o;
  }
};

inline flatbuffers::Offset<LightableDef> CreateLightableDef(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t group = 0,
    int32_t max_ambient_lights = 0,
    int32_t max_directional_lights = 0,
    int32_t max_point_lights = 0) {
  LightableDefBuilder builder_(_fbb);
  builder_.add_max_point_lights(max_point_lights);
  builder_.add_max_directional_lights(max_directional_lights);
  builder_.add_max_ambient_lights(max_ambient_lights);
  builder_.add_group(group);
  return builder_.Finish();
}

}  // namespace lull

#endif  // FLATBUFFERS_GENERATED_LIGHTDEF_LULL_H_
