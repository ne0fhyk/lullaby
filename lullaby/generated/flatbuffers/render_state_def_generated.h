// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_RENDERSTATEDEF_LULL_H_
#define FLATBUFFERS_GENERATED_RENDERSTATEDEF_LULL_H_

#include "flatbuffers/flatbuffers.h"

#include "common_generated.h"

namespace lull {

struct AlphaTestState;

struct BlendState;

struct CullState;

struct DepthState;

struct StencilFunction;

struct StencilOperation;

struct StencilState;

struct ScissorState;

struct RenderState;

enum RenderFunction {
  RenderFunction_Always = 0,
  RenderFunction_Equal = 1,
  RenderFunction_Greater = 2,
  RenderFunction_GreaterEqual = 3,
  RenderFunction_Less = 4,
  RenderFunction_LessEqual = 5,
  RenderFunction_Never = 6,
  RenderFunction_NotEqual = 7,
  RenderFunction_MIN = RenderFunction_Always,
  RenderFunction_MAX = RenderFunction_NotEqual
};

inline RenderFunction (&EnumValuesRenderFunction())[8] {
  static RenderFunction values[] = {
    RenderFunction_Always,
    RenderFunction_Equal,
    RenderFunction_Greater,
    RenderFunction_GreaterEqual,
    RenderFunction_Less,
    RenderFunction_LessEqual,
    RenderFunction_Never,
    RenderFunction_NotEqual
  };
  return values;
}

inline const char **EnumNamesRenderFunction() {
  static const char *names[] = {
    "Always",
    "Equal",
    "Greater",
    "GreaterEqual",
    "Less",
    "LessEqual",
    "Never",
    "NotEqual",
    nullptr
  };
  return names;
}

inline const char *EnumNameRenderFunction(RenderFunction e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesRenderFunction()[index];
}

enum BlendFactor {
  BlendFactor_Zero = 0,
  BlendFactor_One = 1,
  BlendFactor_SrcColor = 2,
  BlendFactor_OneMinusSrcColor = 3,
  BlendFactor_DstColor = 4,
  BlendFactor_OneMinusDstColor = 5,
  BlendFactor_SrcAlpha = 6,
  BlendFactor_OneMinusSrcAlpha = 7,
  BlendFactor_DstAlpha = 8,
  BlendFactor_OneMinusDstAlpha = 9,
  BlendFactor_ConstantColor = 10,
  BlendFactor_OneMinusConstantColor = 11,
  BlendFactor_ConstantAlpha = 12,
  BlendFactor_OneMinusConstantAlpha = 13,
  BlendFactor_SrcAlphaSaturate = 14,
  BlendFactor_MIN = BlendFactor_Zero,
  BlendFactor_MAX = BlendFactor_SrcAlphaSaturate
};

inline BlendFactor (&EnumValuesBlendFactor())[15] {
  static BlendFactor values[] = {
    BlendFactor_Zero,
    BlendFactor_One,
    BlendFactor_SrcColor,
    BlendFactor_OneMinusSrcColor,
    BlendFactor_DstColor,
    BlendFactor_OneMinusDstColor,
    BlendFactor_SrcAlpha,
    BlendFactor_OneMinusSrcAlpha,
    BlendFactor_DstAlpha,
    BlendFactor_OneMinusDstAlpha,
    BlendFactor_ConstantColor,
    BlendFactor_OneMinusConstantColor,
    BlendFactor_ConstantAlpha,
    BlendFactor_OneMinusConstantAlpha,
    BlendFactor_SrcAlphaSaturate
  };
  return values;
}

inline const char **EnumNamesBlendFactor() {
  static const char *names[] = {
    "Zero",
    "One",
    "SrcColor",
    "OneMinusSrcColor",
    "DstColor",
    "OneMinusDstColor",
    "SrcAlpha",
    "OneMinusSrcAlpha",
    "DstAlpha",
    "OneMinusDstAlpha",
    "ConstantColor",
    "OneMinusConstantColor",
    "ConstantAlpha",
    "OneMinusConstantAlpha",
    "SrcAlphaSaturate",
    nullptr
  };
  return names;
}

inline const char *EnumNameBlendFactor(BlendFactor e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesBlendFactor()[index];
}

enum CullFace {
  CullFace_Front = 0,
  CullFace_Back = 1,
  CullFace_FrontAndBack = 2,
  CullFace_MIN = CullFace_Front,
  CullFace_MAX = CullFace_FrontAndBack
};

inline CullFace (&EnumValuesCullFace())[3] {
  static CullFace values[] = {
    CullFace_Front,
    CullFace_Back,
    CullFace_FrontAndBack
  };
  return values;
}

inline const char **EnumNamesCullFace() {
  static const char *names[] = {
    "Front",
    "Back",
    "FrontAndBack",
    nullptr
  };
  return names;
}

inline const char *EnumNameCullFace(CullFace e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesCullFace()[index];
}

enum StencilAction {
  StencilAction_Keep = 0,
  StencilAction_Zero = 1,
  StencilAction_Replace = 2,
  StencilAction_Increment = 3,
  StencilAction_IncrementAndWrap = 4,
  StencilAction_Decrement = 5,
  StencilAction_DecrementAndWrap = 6,
  StencilAction_Invert = 7,
  StencilAction_MIN = StencilAction_Keep,
  StencilAction_MAX = StencilAction_Invert
};

inline StencilAction (&EnumValuesStencilAction())[8] {
  static StencilAction values[] = {
    StencilAction_Keep,
    StencilAction_Zero,
    StencilAction_Replace,
    StencilAction_Increment,
    StencilAction_IncrementAndWrap,
    StencilAction_Decrement,
    StencilAction_DecrementAndWrap,
    StencilAction_Invert
  };
  return values;
}

inline const char **EnumNamesStencilAction() {
  static const char *names[] = {
    "Keep",
    "Zero",
    "Replace",
    "Increment",
    "IncrementAndWrap",
    "Decrement",
    "DecrementAndWrap",
    "Invert",
    nullptr
  };
  return names;
}

inline const char *EnumNameStencilAction(StencilAction e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesStencilAction()[index];
}

struct AlphaTestState FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.AlphaTestState";
  }
  enum {
    VT_ENABLED = 4,
    VT_FUNCTION = 6,
    VT_REF = 8
  };
  bool enabled() const {
    return GetField<uint8_t>(VT_ENABLED, 0) != 0;
  }
  RenderFunction function() const {
    return static_cast<RenderFunction>(GetField<uint16_t>(VT_FUNCTION, 0));
  }
  float ref() const {
    return GetField<float>(VT_REF, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ENABLED) &&
           VerifyField<uint16_t>(verifier, VT_FUNCTION) &&
           VerifyField<float>(verifier, VT_REF) &&
           verifier.EndTable();
  }
};

struct AlphaTestStateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_enabled(bool enabled) {
    fbb_.AddElement<uint8_t>(AlphaTestState::VT_ENABLED, static_cast<uint8_t>(enabled), 0);
  }
  void add_function(RenderFunction function) {
    fbb_.AddElement<uint16_t>(AlphaTestState::VT_FUNCTION, static_cast<uint16_t>(function), 0);
  }
  void add_ref(float ref) {
    fbb_.AddElement<float>(AlphaTestState::VT_REF, ref, 0.0f);
  }
  AlphaTestStateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AlphaTestStateBuilder &operator=(const AlphaTestStateBuilder &);
  flatbuffers::Offset<AlphaTestState> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<AlphaTestState>(end);
    return o;
  }
};

inline flatbuffers::Offset<AlphaTestState> CreateAlphaTestState(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool enabled = false,
    RenderFunction function = RenderFunction_Always,
    float ref = 0.0f) {
  AlphaTestStateBuilder builder_(_fbb);
  builder_.add_ref(ref);
  builder_.add_function(function);
  builder_.add_enabled(enabled);
  return builder_.Finish();
}

struct BlendState FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.BlendState";
  }
  enum {
    VT_ENABLED = 4,
    VT_SRC_ALPHA = 6,
    VT_SRC_COLOR = 8,
    VT_DST_ALPHA = 10,
    VT_DST_COLOR = 12
  };
  bool enabled() const {
    return GetField<uint8_t>(VT_ENABLED, 0) != 0;
  }
  BlendFactor src_alpha() const {
    return static_cast<BlendFactor>(GetField<uint16_t>(VT_SRC_ALPHA, 1));
  }
  BlendFactor src_color() const {
    return static_cast<BlendFactor>(GetField<uint16_t>(VT_SRC_COLOR, 1));
  }
  BlendFactor dst_alpha() const {
    return static_cast<BlendFactor>(GetField<uint16_t>(VT_DST_ALPHA, 0));
  }
  BlendFactor dst_color() const {
    return static_cast<BlendFactor>(GetField<uint16_t>(VT_DST_COLOR, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ENABLED) &&
           VerifyField<uint16_t>(verifier, VT_SRC_ALPHA) &&
           VerifyField<uint16_t>(verifier, VT_SRC_COLOR) &&
           VerifyField<uint16_t>(verifier, VT_DST_ALPHA) &&
           VerifyField<uint16_t>(verifier, VT_DST_COLOR) &&
           verifier.EndTable();
  }
};

struct BlendStateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_enabled(bool enabled) {
    fbb_.AddElement<uint8_t>(BlendState::VT_ENABLED, static_cast<uint8_t>(enabled), 0);
  }
  void add_src_alpha(BlendFactor src_alpha) {
    fbb_.AddElement<uint16_t>(BlendState::VT_SRC_ALPHA, static_cast<uint16_t>(src_alpha), 1);
  }
  void add_src_color(BlendFactor src_color) {
    fbb_.AddElement<uint16_t>(BlendState::VT_SRC_COLOR, static_cast<uint16_t>(src_color), 1);
  }
  void add_dst_alpha(BlendFactor dst_alpha) {
    fbb_.AddElement<uint16_t>(BlendState::VT_DST_ALPHA, static_cast<uint16_t>(dst_alpha), 0);
  }
  void add_dst_color(BlendFactor dst_color) {
    fbb_.AddElement<uint16_t>(BlendState::VT_DST_COLOR, static_cast<uint16_t>(dst_color), 0);
  }
  BlendStateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BlendStateBuilder &operator=(const BlendStateBuilder &);
  flatbuffers::Offset<BlendState> Finish() {
    const auto end = fbb_.EndTable(start_, 5);
    auto o = flatbuffers::Offset<BlendState>(end);
    return o;
  }
};

inline flatbuffers::Offset<BlendState> CreateBlendState(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool enabled = false,
    BlendFactor src_alpha = BlendFactor_One,
    BlendFactor src_color = BlendFactor_One,
    BlendFactor dst_alpha = BlendFactor_Zero,
    BlendFactor dst_color = BlendFactor_Zero) {
  BlendStateBuilder builder_(_fbb);
  builder_.add_dst_color(dst_color);
  builder_.add_dst_alpha(dst_alpha);
  builder_.add_src_color(src_color);
  builder_.add_src_alpha(src_alpha);
  builder_.add_enabled(enabled);
  return builder_.Finish();
}

struct CullState FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.CullState";
  }
  enum {
    VT_FACE = 4,
    VT_ENABLED = 6
  };
  CullFace face() const {
    return static_cast<CullFace>(GetField<uint16_t>(VT_FACE, 1));
  }
  bool enabled() const {
    return GetField<uint8_t>(VT_ENABLED, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_FACE) &&
           VerifyField<uint8_t>(verifier, VT_ENABLED) &&
           verifier.EndTable();
  }
};

struct CullStateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_face(CullFace face) {
    fbb_.AddElement<uint16_t>(CullState::VT_FACE, static_cast<uint16_t>(face), 1);
  }
  void add_enabled(bool enabled) {
    fbb_.AddElement<uint8_t>(CullState::VT_ENABLED, static_cast<uint8_t>(enabled), 0);
  }
  CullStateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CullStateBuilder &operator=(const CullStateBuilder &);
  flatbuffers::Offset<CullState> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<CullState>(end);
    return o;
  }
};

inline flatbuffers::Offset<CullState> CreateCullState(
    flatbuffers::FlatBufferBuilder &_fbb,
    CullFace face = CullFace_Back,
    bool enabled = false) {
  CullStateBuilder builder_(_fbb);
  builder_.add_face(face);
  builder_.add_enabled(enabled);
  return builder_.Finish();
}

struct DepthState FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.DepthState";
  }
  enum {
    VT_FUNCTION = 4,
    VT_TEST_ENABLED = 6,
    VT_WRITE_ENABLED = 8
  };
  RenderFunction function() const {
    return static_cast<RenderFunction>(GetField<uint16_t>(VT_FUNCTION, 0));
  }
  bool test_enabled() const {
    return GetField<uint8_t>(VT_TEST_ENABLED, 0) != 0;
  }
  bool write_enabled() const {
    return GetField<uint8_t>(VT_WRITE_ENABLED, 1) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_FUNCTION) &&
           VerifyField<uint8_t>(verifier, VT_TEST_ENABLED) &&
           VerifyField<uint8_t>(verifier, VT_WRITE_ENABLED) &&
           verifier.EndTable();
  }
};

struct DepthStateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_function(RenderFunction function) {
    fbb_.AddElement<uint16_t>(DepthState::VT_FUNCTION, static_cast<uint16_t>(function), 0);
  }
  void add_test_enabled(bool test_enabled) {
    fbb_.AddElement<uint8_t>(DepthState::VT_TEST_ENABLED, static_cast<uint8_t>(test_enabled), 0);
  }
  void add_write_enabled(bool write_enabled) {
    fbb_.AddElement<uint8_t>(DepthState::VT_WRITE_ENABLED, static_cast<uint8_t>(write_enabled), 1);
  }
  DepthStateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DepthStateBuilder &operator=(const DepthStateBuilder &);
  flatbuffers::Offset<DepthState> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<DepthState>(end);
    return o;
  }
};

inline flatbuffers::Offset<DepthState> CreateDepthState(
    flatbuffers::FlatBufferBuilder &_fbb,
    RenderFunction function = RenderFunction_Always,
    bool test_enabled = false,
    bool write_enabled = true) {
  DepthStateBuilder builder_(_fbb);
  builder_.add_function(function);
  builder_.add_write_enabled(write_enabled);
  builder_.add_test_enabled(test_enabled);
  return builder_.Finish();
}

struct StencilFunction FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.StencilFunction";
  }
  enum {
    VT_FUNCTION = 4,
    VT_REF = 6,
    VT_MASK = 8
  };
  RenderFunction function() const {
    return static_cast<RenderFunction>(GetField<uint16_t>(VT_FUNCTION, 0));
  }
  int32_t ref() const {
    return GetField<int32_t>(VT_REF, 0);
  }
  uint32_t mask() const {
    return GetField<uint32_t>(VT_MASK, 1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_FUNCTION) &&
           VerifyField<int32_t>(verifier, VT_REF) &&
           VerifyField<uint32_t>(verifier, VT_MASK) &&
           verifier.EndTable();
  }
};

struct StencilFunctionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_function(RenderFunction function) {
    fbb_.AddElement<uint16_t>(StencilFunction::VT_FUNCTION, static_cast<uint16_t>(function), 0);
  }
  void add_ref(int32_t ref) {
    fbb_.AddElement<int32_t>(StencilFunction::VT_REF, ref, 0);
  }
  void add_mask(uint32_t mask) {
    fbb_.AddElement<uint32_t>(StencilFunction::VT_MASK, mask, 1);
  }
  StencilFunctionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StencilFunctionBuilder &operator=(const StencilFunctionBuilder &);
  flatbuffers::Offset<StencilFunction> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<StencilFunction>(end);
    return o;
  }
};

inline flatbuffers::Offset<StencilFunction> CreateStencilFunction(
    flatbuffers::FlatBufferBuilder &_fbb,
    RenderFunction function = RenderFunction_Always,
    int32_t ref = 0,
    uint32_t mask = 1) {
  StencilFunctionBuilder builder_(_fbb);
  builder_.add_mask(mask);
  builder_.add_ref(ref);
  builder_.add_function(function);
  return builder_.Finish();
}

struct StencilOperation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.StencilOperation";
  }
  enum {
    VT_STENCIL_FAIL = 4,
    VT_DEPTH_FAIL = 6,
    VT_PASS = 8
  };
  StencilAction stencil_fail() const {
    return static_cast<StencilAction>(GetField<uint16_t>(VT_STENCIL_FAIL, 0));
  }
  StencilAction depth_fail() const {
    return static_cast<StencilAction>(GetField<uint16_t>(VT_DEPTH_FAIL, 0));
  }
  StencilAction pass() const {
    return static_cast<StencilAction>(GetField<uint16_t>(VT_PASS, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_STENCIL_FAIL) &&
           VerifyField<uint16_t>(verifier, VT_DEPTH_FAIL) &&
           VerifyField<uint16_t>(verifier, VT_PASS) &&
           verifier.EndTable();
  }
};

struct StencilOperationBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stencil_fail(StencilAction stencil_fail) {
    fbb_.AddElement<uint16_t>(StencilOperation::VT_STENCIL_FAIL, static_cast<uint16_t>(stencil_fail), 0);
  }
  void add_depth_fail(StencilAction depth_fail) {
    fbb_.AddElement<uint16_t>(StencilOperation::VT_DEPTH_FAIL, static_cast<uint16_t>(depth_fail), 0);
  }
  void add_pass(StencilAction pass) {
    fbb_.AddElement<uint16_t>(StencilOperation::VT_PASS, static_cast<uint16_t>(pass), 0);
  }
  StencilOperationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StencilOperationBuilder &operator=(const StencilOperationBuilder &);
  flatbuffers::Offset<StencilOperation> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<StencilOperation>(end);
    return o;
  }
};

inline flatbuffers::Offset<StencilOperation> CreateStencilOperation(
    flatbuffers::FlatBufferBuilder &_fbb,
    StencilAction stencil_fail = StencilAction_Keep,
    StencilAction depth_fail = StencilAction_Keep,
    StencilAction pass = StencilAction_Keep) {
  StencilOperationBuilder builder_(_fbb);
  builder_.add_pass(pass);
  builder_.add_depth_fail(depth_fail);
  builder_.add_stencil_fail(stencil_fail);
  return builder_.Finish();
}

struct StencilState FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.StencilState";
  }
  enum {
    VT_ENABLED = 4,
    VT_BACK_FUNCTION = 6,
    VT_BACK_OP = 8,
    VT_FRONT_FUNCTION = 10,
    VT_FRONT_OP = 12
  };
  bool enabled() const {
    return GetField<uint8_t>(VT_ENABLED, 0) != 0;
  }
  const StencilFunction *back_function() const {
    return GetPointer<const StencilFunction *>(VT_BACK_FUNCTION);
  }
  const StencilOperation *back_op() const {
    return GetPointer<const StencilOperation *>(VT_BACK_OP);
  }
  const StencilFunction *front_function() const {
    return GetPointer<const StencilFunction *>(VT_FRONT_FUNCTION);
  }
  const StencilOperation *front_op() const {
    return GetPointer<const StencilOperation *>(VT_FRONT_OP);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ENABLED) &&
           VerifyOffset(verifier, VT_BACK_FUNCTION) &&
           verifier.VerifyTable(back_function()) &&
           VerifyOffset(verifier, VT_BACK_OP) &&
           verifier.VerifyTable(back_op()) &&
           VerifyOffset(verifier, VT_FRONT_FUNCTION) &&
           verifier.VerifyTable(front_function()) &&
           VerifyOffset(verifier, VT_FRONT_OP) &&
           verifier.VerifyTable(front_op()) &&
           verifier.EndTable();
  }
};

struct StencilStateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_enabled(bool enabled) {
    fbb_.AddElement<uint8_t>(StencilState::VT_ENABLED, static_cast<uint8_t>(enabled), 0);
  }
  void add_back_function(flatbuffers::Offset<StencilFunction> back_function) {
    fbb_.AddOffset(StencilState::VT_BACK_FUNCTION, back_function);
  }
  void add_back_op(flatbuffers::Offset<StencilOperation> back_op) {
    fbb_.AddOffset(StencilState::VT_BACK_OP, back_op);
  }
  void add_front_function(flatbuffers::Offset<StencilFunction> front_function) {
    fbb_.AddOffset(StencilState::VT_FRONT_FUNCTION, front_function);
  }
  void add_front_op(flatbuffers::Offset<StencilOperation> front_op) {
    fbb_.AddOffset(StencilState::VT_FRONT_OP, front_op);
  }
  StencilStateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StencilStateBuilder &operator=(const StencilStateBuilder &);
  flatbuffers::Offset<StencilState> Finish() {
    const auto end = fbb_.EndTable(start_, 5);
    auto o = flatbuffers::Offset<StencilState>(end);
    return o;
  }
};

inline flatbuffers::Offset<StencilState> CreateStencilState(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool enabled = false,
    flatbuffers::Offset<StencilFunction> back_function = 0,
    flatbuffers::Offset<StencilOperation> back_op = 0,
    flatbuffers::Offset<StencilFunction> front_function = 0,
    flatbuffers::Offset<StencilOperation> front_op = 0) {
  StencilStateBuilder builder_(_fbb);
  builder_.add_front_op(front_op);
  builder_.add_front_function(front_function);
  builder_.add_back_op(back_op);
  builder_.add_back_function(back_function);
  builder_.add_enabled(enabled);
  return builder_.Finish();
}

struct ScissorState FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.ScissorState";
  }
  enum {
    VT_ENABLED = 4
  };
  bool enabled() const {
    return GetField<uint8_t>(VT_ENABLED, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ENABLED) &&
           verifier.EndTable();
  }
};

struct ScissorStateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_enabled(bool enabled) {
    fbb_.AddElement<uint8_t>(ScissorState::VT_ENABLED, static_cast<uint8_t>(enabled), 0);
  }
  ScissorStateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ScissorStateBuilder &operator=(const ScissorStateBuilder &);
  flatbuffers::Offset<ScissorState> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<ScissorState>(end);
    return o;
  }
};

inline flatbuffers::Offset<ScissorState> CreateScissorState(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool enabled = false) {
  ScissorStateBuilder builder_(_fbb);
  builder_.add_enabled(enabled);
  return builder_.Finish();
}

struct RenderState FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.RenderState";
  }
  enum {
    VT_ALPHA_TEST_STATE = 4,
    VT_BLEND_STATE = 6,
    VT_CULL_STATE = 8,
    VT_DEPTH_STATE = 10,
    VT_SCISSOR_STATE = 12,
    VT_STENCIL_STATE = 14,
    VT_VIEWPORT = 16
  };
  const AlphaTestState *alpha_test_state() const {
    return GetPointer<const AlphaTestState *>(VT_ALPHA_TEST_STATE);
  }
  const BlendState *blend_state() const {
    return GetPointer<const BlendState *>(VT_BLEND_STATE);
  }
  const CullState *cull_state() const {
    return GetPointer<const CullState *>(VT_CULL_STATE);
  }
  const DepthState *depth_state() const {
    return GetPointer<const DepthState *>(VT_DEPTH_STATE);
  }
  const ScissorState *scissor_state() const {
    return GetPointer<const ScissorState *>(VT_SCISSOR_STATE);
  }
  const StencilState *stencil_state() const {
    return GetPointer<const StencilState *>(VT_STENCIL_STATE);
  }
  const lull::Rect *viewport() const {
    return GetStruct<const lull::Rect *>(VT_VIEWPORT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ALPHA_TEST_STATE) &&
           verifier.VerifyTable(alpha_test_state()) &&
           VerifyOffset(verifier, VT_BLEND_STATE) &&
           verifier.VerifyTable(blend_state()) &&
           VerifyOffset(verifier, VT_CULL_STATE) &&
           verifier.VerifyTable(cull_state()) &&
           VerifyOffset(verifier, VT_DEPTH_STATE) &&
           verifier.VerifyTable(depth_state()) &&
           VerifyOffset(verifier, VT_SCISSOR_STATE) &&
           verifier.VerifyTable(scissor_state()) &&
           VerifyOffset(verifier, VT_STENCIL_STATE) &&
           verifier.VerifyTable(stencil_state()) &&
           VerifyField<lull::Rect>(verifier, VT_VIEWPORT) &&
           verifier.EndTable();
  }
};

struct RenderStateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_alpha_test_state(flatbuffers::Offset<AlphaTestState> alpha_test_state) {
    fbb_.AddOffset(RenderState::VT_ALPHA_TEST_STATE, alpha_test_state);
  }
  void add_blend_state(flatbuffers::Offset<BlendState> blend_state) {
    fbb_.AddOffset(RenderState::VT_BLEND_STATE, blend_state);
  }
  void add_cull_state(flatbuffers::Offset<CullState> cull_state) {
    fbb_.AddOffset(RenderState::VT_CULL_STATE, cull_state);
  }
  void add_depth_state(flatbuffers::Offset<DepthState> depth_state) {
    fbb_.AddOffset(RenderState::VT_DEPTH_STATE, depth_state);
  }
  void add_scissor_state(flatbuffers::Offset<ScissorState> scissor_state) {
    fbb_.AddOffset(RenderState::VT_SCISSOR_STATE, scissor_state);
  }
  void add_stencil_state(flatbuffers::Offset<StencilState> stencil_state) {
    fbb_.AddOffset(RenderState::VT_STENCIL_STATE, stencil_state);
  }
  void add_viewport(const lull::Rect *viewport) {
    fbb_.AddStruct(RenderState::VT_VIEWPORT, viewport);
  }
  RenderStateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RenderStateBuilder &operator=(const RenderStateBuilder &);
  flatbuffers::Offset<RenderState> Finish() {
    const auto end = fbb_.EndTable(start_, 7);
    auto o = flatbuffers::Offset<RenderState>(end);
    return o;
  }
};

inline flatbuffers::Offset<RenderState> CreateRenderState(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<AlphaTestState> alpha_test_state = 0,
    flatbuffers::Offset<BlendState> blend_state = 0,
    flatbuffers::Offset<CullState> cull_state = 0,
    flatbuffers::Offset<DepthState> depth_state = 0,
    flatbuffers::Offset<ScissorState> scissor_state = 0,
    flatbuffers::Offset<StencilState> stencil_state = 0,
    const lull::Rect *viewport = 0) {
  RenderStateBuilder builder_(_fbb);
  builder_.add_viewport(viewport);
  builder_.add_stencil_state(stencil_state);
  builder_.add_scissor_state(scissor_state);
  builder_.add_depth_state(depth_state);
  builder_.add_cull_state(cull_state);
  builder_.add_blend_state(blend_state);
  builder_.add_alpha_test_state(alpha_test_state);
  return builder_.Finish();
}

}  // namespace lull

#endif  // FLATBUFFERS_GENERATED_RENDERSTATEDEF_LULL_H_
