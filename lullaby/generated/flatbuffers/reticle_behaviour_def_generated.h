// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_RETICLEBEHAVIOURDEF_LULL_H_
#define FLATBUFFERS_GENERATED_RETICLEBEHAVIOURDEF_LULL_H_

#include "flatbuffers/flatbuffers.h"

#include "common_generated.h"

namespace lull {

struct ReticleBehaviourDef;

enum ReticleCollisionBehaviour {
  /// Handle the collision directly on this entity.
  ReticleCollisionBehaviour_HandleAlone = 0  /// Traverse to parents to find an entity with |HandleForDescendants|.
,
  ReticleCollisionBehaviour_FindAncestor = 1  /// Handle reticle collisions passed from descendants with |FindAncestor|.
,
  ReticleCollisionBehaviour_HandleDescendants = 2,
  ReticleCollisionBehaviour_MIN = ReticleCollisionBehaviour_HandleAlone,
  ReticleCollisionBehaviour_MAX = ReticleCollisionBehaviour_HandleDescendants
};

inline ReticleCollisionBehaviour (&EnumValuesReticleCollisionBehaviour())[3] {
  static ReticleCollisionBehaviour values[] = {
    ReticleCollisionBehaviour_HandleAlone,
    ReticleCollisionBehaviour_FindAncestor,
    ReticleCollisionBehaviour_HandleDescendants
  };
  return values;
}

inline const char **EnumNamesReticleCollisionBehaviour() {
  static const char *names[] = {
    "HandleAlone",
    "FindAncestor",
    "HandleDescendants",
    nullptr
  };
  return names;
}

inline const char *EnumNameReticleCollisionBehaviour(ReticleCollisionBehaviour e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesReticleCollisionBehaviour()[index];
}

/// ReticleBehaviourDef modifies how a collideable entity will interact with the
/// reticle.
struct ReticleBehaviourDef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.ReticleBehaviourDef";
  }
  enum {
    VT_HOVER_START_DEAD_ZONE = 4,
    VT_COLLISION_BEHAVIOUR = 6,
    VT_INTERACTIVE_IF_HANDLE_DESCENDANTS = 8
  };
  /// Scales the entity's Aabb down when determining if it is targeted.
  /// Specifically, the dead zone is the outer part of the Aabb that will not
  /// trigger a hover-start event even if being collided with. This is useful
  /// for entities that change positions when targeted, which could move them
  /// out of collision and result in bouncing. These values can only shrink the
  /// Aabb, and should be absolute values. They will be applied to both sides of
  /// the Aabb. For example, an entity centered at origin with a 3x3x3 Aabb with
  /// a dead zone of (0.5,1,0.5) will only become targeted when the reticle
  /// collides with the 2x1x2 Aabb centered at the origin.
  const lull::Vec3 *hover_start_dead_zone() const {
    return GetStruct<const lull::Vec3 *>(VT_HOVER_START_DEAD_ZONE);
  }
  /// How this entity should handle reticle collisions.
  ReticleCollisionBehaviour collision_behaviour() const {
    return static_cast<ReticleCollisionBehaviour>(GetField<int32_t>(VT_COLLISION_BEHAVIOUR, 0));
  }
  /// If set to true and this entity has HandleDescendants, it's interactivity
  /// and default interactivity will be set. Ignored if |collision_behaviour| is
  /// not HandleDescendants.
  bool interactive_if_handle_descendants() const {
    return GetField<uint8_t>(VT_INTERACTIVE_IF_HANDLE_DESCENDANTS, 1) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<lull::Vec3>(verifier, VT_HOVER_START_DEAD_ZONE) &&
           VerifyField<int32_t>(verifier, VT_COLLISION_BEHAVIOUR) &&
           VerifyField<uint8_t>(verifier, VT_INTERACTIVE_IF_HANDLE_DESCENDANTS) &&
           verifier.EndTable();
  }
};

struct ReticleBehaviourDefBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_hover_start_dead_zone(const lull::Vec3 *hover_start_dead_zone) {
    fbb_.AddStruct(ReticleBehaviourDef::VT_HOVER_START_DEAD_ZONE, hover_start_dead_zone);
  }
  void add_collision_behaviour(ReticleCollisionBehaviour collision_behaviour) {
    fbb_.AddElement<int32_t>(ReticleBehaviourDef::VT_COLLISION_BEHAVIOUR, static_cast<int32_t>(collision_behaviour), 0);
  }
  void add_interactive_if_handle_descendants(bool interactive_if_handle_descendants) {
    fbb_.AddElement<uint8_t>(ReticleBehaviourDef::VT_INTERACTIVE_IF_HANDLE_DESCENDANTS, static_cast<uint8_t>(interactive_if_handle_descendants), 1);
  }
  ReticleBehaviourDefBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReticleBehaviourDefBuilder &operator=(const ReticleBehaviourDefBuilder &);
  flatbuffers::Offset<ReticleBehaviourDef> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<ReticleBehaviourDef>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReticleBehaviourDef> CreateReticleBehaviourDef(
    flatbuffers::FlatBufferBuilder &_fbb,
    const lull::Vec3 *hover_start_dead_zone = 0,
    ReticleCollisionBehaviour collision_behaviour = ReticleCollisionBehaviour_HandleAlone,
    bool interactive_if_handle_descendants = true) {
  ReticleBehaviourDefBuilder builder_(_fbb);
  builder_.add_collision_behaviour(collision_behaviour);
  builder_.add_hover_start_dead_zone(hover_start_dead_zone);
  builder_.add_interactive_if_handle_descendants(interactive_if_handle_descendants);
  return builder_.Finish();
}

}  // namespace lull

#endif  // FLATBUFFERS_GENERATED_RETICLEBEHAVIOURDEF_LULL_H_
