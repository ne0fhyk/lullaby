// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_RETICLEDEF_LULL_H_
#define FLATBUFFERS_GENERATED_RETICLEDEF_LULL_H_

#include "flatbuffers/flatbuffers.h"

#include "common_generated.h"

namespace lull {

struct ReticleDef;

/// Configures the reticle (VR cursor).
/// Apps should consider reusing: lullaby/data/blueprints/reticle.json.
/// In case of changing any of these values, please update reticle_template.fbs.
struct ReticleDef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.ReticleDef";
  }
  enum {
    VT_RING_ACTIVE_DIAMETER = 4,
    VT_RING_INACTIVE_DIAMETER = 6,
    VT_RING_HALF_THICKNESS = 8,
    VT_HIT_COLOR = 10,
    VT_NO_HIT_COLOR = 12,
    VT_NO_HIT_DISTANCE = 14,
    VT_INNER_HOLE = 16,
    VT_INNER_RING_END = 18,
    VT_INNER_RING_THICKNESS = 20,
    VT_MID_RING_END = 22,
    VT_MID_RING_OPACITY = 24,
    VT_ERGO_ANGLE_OFFSET = 26,
    VT_DEVICE_PREFERENCE = 28
  };
  float ring_active_diameter() const {
    return GetField<float>(VT_RING_ACTIVE_DIAMETER, 1.0f);
  }
  float ring_inactive_diameter() const {
    return GetField<float>(VT_RING_INACTIVE_DIAMETER, 1.0f);
  }
  /// OBSOLETE
  float ring_half_thickness() const {
    return GetField<float>(VT_RING_HALF_THICKNESS, 0.11f);
  }
  const Color *hit_color() const {
    return GetStruct<const Color *>(VT_HIT_COLOR);
  }
  const Color *no_hit_color() const {
    return GetStruct<const Color *>(VT_NO_HIT_COLOR);
  }
  float no_hit_distance() const {
    return GetField<float>(VT_NO_HIT_DISTANCE, 2.0f);
  }
  /// Next 5 values are all in the range of [0-1], with 1 being the full radius
  /// of the ring_diameter.
  /// Distance from center to start of solid color ring.
  /// This - |inner_ring_thickness| will be the distance to the start of color.
  float inner_hole() const {
    return GetField<float>(VT_INNER_HOLE, 0.0f);
  }
  /// Distance from center to end of solid color ring.
  /// This + |inner_ring_thickness| will be the distance to the end of color.
  float inner_ring_end() const {
    return GetField<float>(VT_INNER_RING_END, 0.177f);
  }
  /// Feathering that will be applied inside |inner_hole| and outside
  /// |inner_ring_end|.
  float inner_ring_thickness() const {
    return GetField<float>(VT_INNER_RING_THICKNESS, 0.14f);
  }
  /// Distance from center to end of black ring.
  float mid_ring_end() const {
    return GetField<float>(VT_MID_RING_END, 0.177f);
  }
  /// Opacity of black ring outside of the colored ring.
  float mid_ring_opacity() const {
    return GetField<float>(VT_MID_RING_OPACITY, 0.22f);
  }
  float ergo_angle_offset() const {
    return GetField<float>(VT_ERGO_ANGLE_OFFSET, -0.26f);
  }
  /// An ordered list of what input device should drive the reticle.  If the
  /// first device is connected, it will control the reticle.  Control will fall
  /// down the array, and if no devices are connected the reticle will be
  /// disabled.  Defaults to [Controller, Hmd] if not set.
  const flatbuffers::Vector<int32_t> *device_preference() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DEVICE_PREFERENCE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_RING_ACTIVE_DIAMETER) &&
           VerifyField<float>(verifier, VT_RING_INACTIVE_DIAMETER) &&
           VerifyField<float>(verifier, VT_RING_HALF_THICKNESS) &&
           VerifyField<Color>(verifier, VT_HIT_COLOR) &&
           VerifyField<Color>(verifier, VT_NO_HIT_COLOR) &&
           VerifyField<float>(verifier, VT_NO_HIT_DISTANCE) &&
           VerifyField<float>(verifier, VT_INNER_HOLE) &&
           VerifyField<float>(verifier, VT_INNER_RING_END) &&
           VerifyField<float>(verifier, VT_INNER_RING_THICKNESS) &&
           VerifyField<float>(verifier, VT_MID_RING_END) &&
           VerifyField<float>(verifier, VT_MID_RING_OPACITY) &&
           VerifyField<float>(verifier, VT_ERGO_ANGLE_OFFSET) &&
           VerifyOffset(verifier, VT_DEVICE_PREFERENCE) &&
           verifier.Verify(device_preference()) &&
           verifier.EndTable();
  }
};

struct ReticleDefBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ring_active_diameter(float ring_active_diameter) {
    fbb_.AddElement<float>(ReticleDef::VT_RING_ACTIVE_DIAMETER, ring_active_diameter, 1.0f);
  }
  void add_ring_inactive_diameter(float ring_inactive_diameter) {
    fbb_.AddElement<float>(ReticleDef::VT_RING_INACTIVE_DIAMETER, ring_inactive_diameter, 1.0f);
  }
  void add_ring_half_thickness(float ring_half_thickness) {
    fbb_.AddElement<float>(ReticleDef::VT_RING_HALF_THICKNESS, ring_half_thickness, 0.11f);
  }
  void add_hit_color(const Color *hit_color) {
    fbb_.AddStruct(ReticleDef::VT_HIT_COLOR, hit_color);
  }
  void add_no_hit_color(const Color *no_hit_color) {
    fbb_.AddStruct(ReticleDef::VT_NO_HIT_COLOR, no_hit_color);
  }
  void add_no_hit_distance(float no_hit_distance) {
    fbb_.AddElement<float>(ReticleDef::VT_NO_HIT_DISTANCE, no_hit_distance, 2.0f);
  }
  void add_inner_hole(float inner_hole) {
    fbb_.AddElement<float>(ReticleDef::VT_INNER_HOLE, inner_hole, 0.0f);
  }
  void add_inner_ring_end(float inner_ring_end) {
    fbb_.AddElement<float>(ReticleDef::VT_INNER_RING_END, inner_ring_end, 0.177f);
  }
  void add_inner_ring_thickness(float inner_ring_thickness) {
    fbb_.AddElement<float>(ReticleDef::VT_INNER_RING_THICKNESS, inner_ring_thickness, 0.14f);
  }
  void add_mid_ring_end(float mid_ring_end) {
    fbb_.AddElement<float>(ReticleDef::VT_MID_RING_END, mid_ring_end, 0.177f);
  }
  void add_mid_ring_opacity(float mid_ring_opacity) {
    fbb_.AddElement<float>(ReticleDef::VT_MID_RING_OPACITY, mid_ring_opacity, 0.22f);
  }
  void add_ergo_angle_offset(float ergo_angle_offset) {
    fbb_.AddElement<float>(ReticleDef::VT_ERGO_ANGLE_OFFSET, ergo_angle_offset, -0.26f);
  }
  void add_device_preference(flatbuffers::Offset<flatbuffers::Vector<int32_t>> device_preference) {
    fbb_.AddOffset(ReticleDef::VT_DEVICE_PREFERENCE, device_preference);
  }
  explicit ReticleDefBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReticleDefBuilder &operator=(const ReticleDefBuilder &);
  flatbuffers::Offset<ReticleDef> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReticleDef>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReticleDef> CreateReticleDef(
    flatbuffers::FlatBufferBuilder &_fbb,
    float ring_active_diameter = 1.0f,
    float ring_inactive_diameter = 1.0f,
    float ring_half_thickness = 0.11f,
    const Color *hit_color = 0,
    const Color *no_hit_color = 0,
    float no_hit_distance = 2.0f,
    float inner_hole = 0.0f,
    float inner_ring_end = 0.177f,
    float inner_ring_thickness = 0.14f,
    float mid_ring_end = 0.177f,
    float mid_ring_opacity = 0.22f,
    float ergo_angle_offset = -0.26f,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> device_preference = 0) {
  ReticleDefBuilder builder_(_fbb);
  builder_.add_device_preference(device_preference);
  builder_.add_ergo_angle_offset(ergo_angle_offset);
  builder_.add_mid_ring_opacity(mid_ring_opacity);
  builder_.add_mid_ring_end(mid_ring_end);
  builder_.add_inner_ring_thickness(inner_ring_thickness);
  builder_.add_inner_ring_end(inner_ring_end);
  builder_.add_inner_hole(inner_hole);
  builder_.add_no_hit_distance(no_hit_distance);
  builder_.add_no_hit_color(no_hit_color);
  builder_.add_hit_color(hit_color);
  builder_.add_ring_half_thickness(ring_half_thickness);
  builder_.add_ring_inactive_diameter(ring_inactive_diameter);
  builder_.add_ring_active_diameter(ring_active_diameter);
  return builder_.Finish();
}

inline flatbuffers::Offset<ReticleDef> CreateReticleDefDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    float ring_active_diameter = 1.0f,
    float ring_inactive_diameter = 1.0f,
    float ring_half_thickness = 0.11f,
    const Color *hit_color = 0,
    const Color *no_hit_color = 0,
    float no_hit_distance = 2.0f,
    float inner_hole = 0.0f,
    float inner_ring_end = 0.177f,
    float inner_ring_thickness = 0.14f,
    float mid_ring_end = 0.177f,
    float mid_ring_opacity = 0.22f,
    float ergo_angle_offset = -0.26f,
    const std::vector<int32_t> *device_preference = nullptr) {
  return lull::CreateReticleDef(
      _fbb,
      ring_active_diameter,
      ring_inactive_diameter,
      ring_half_thickness,
      hit_color,
      no_hit_color,
      no_hit_distance,
      inner_hole,
      inner_ring_end,
      inner_ring_thickness,
      mid_ring_end,
      mid_ring_opacity,
      ergo_angle_offset,
      device_preference ? _fbb.CreateVector<int32_t>(*device_preference) : 0);
}

inline const lull::ReticleDef *GetReticleDef(const void *buf) {
  return flatbuffers::GetRoot<lull::ReticleDef>(buf);
}

inline bool VerifyReticleDefBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<lull::ReticleDef>(nullptr);
}

inline void FinishReticleDefBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<lull::ReticleDef> root) {
  fbb.Finish(root);
}

}  // namespace lull

#endif  // FLATBUFFERS_GENERATED_RETICLEDEF_LULL_H_
