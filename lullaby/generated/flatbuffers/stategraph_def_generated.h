// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_STATEGRAPHDEF_LULL_H_
#define FLATBUFFERS_GENERATED_STATEGRAPHDEF_LULL_H_

#include "flatbuffers/flatbuffers.h"

#include "common_generated.h"

namespace lull {

struct StategraphDef;

/// The StategraphSystem is responsible for advancing and tracking the progress
/// of an entity within a stategraph.
///
/// A stategraph is a collection of states and transitions that allows entity
/// animations to be played and transitioned at a higher level.  Instead of
/// focusing on the specific animation to play at a given time, the logic of
/// playing and transitioning animations is encoded in a graph.  Users of the
/// StategraphSystem can then issue requests to transition to a target state
/// (eg. idle, walk, jump, etc.), and all the logic of how to reach that target
/// state will be handled by the StategraphSystem.
struct StategraphDef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.StategraphDef";
  }
  enum {
    VT_ANIMATION_STATEGRAPH = 4,
    VT_INITIAL_STATE = 6
  };
  /// The path to the stategraph to use for this entity.
  const flatbuffers::String *animation_stategraph() const {
    return GetPointer<const flatbuffers::String *>(VT_ANIMATION_STATEGRAPH);
  }
  /// The first state within the stategraph at which to start.
  uint32_t initial_state() const {
    return GetField<uint32_t>(VT_INITIAL_STATE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ANIMATION_STATEGRAPH) &&
           verifier.Verify(animation_stategraph()) &&
           VerifyField<uint32_t>(verifier, VT_INITIAL_STATE) &&
           verifier.EndTable();
  }
};

struct StategraphDefBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_animation_stategraph(flatbuffers::Offset<flatbuffers::String> animation_stategraph) {
    fbb_.AddOffset(StategraphDef::VT_ANIMATION_STATEGRAPH, animation_stategraph);
  }
  void add_initial_state(uint32_t initial_state) {
    fbb_.AddElement<uint32_t>(StategraphDef::VT_INITIAL_STATE, initial_state, 0);
  }
  explicit StategraphDefBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StategraphDefBuilder &operator=(const StategraphDefBuilder &);
  flatbuffers::Offset<StategraphDef> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StategraphDef>(end);
    return o;
  }
};

inline flatbuffers::Offset<StategraphDef> CreateStategraphDef(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> animation_stategraph = 0,
    uint32_t initial_state = 0) {
  StategraphDefBuilder builder_(_fbb);
  builder_.add_initial_state(initial_state);
  builder_.add_animation_stategraph(animation_stategraph);
  return builder_.Finish();
}

inline flatbuffers::Offset<StategraphDef> CreateStategraphDefDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *animation_stategraph = nullptr,
    uint32_t initial_state = 0) {
  return lull::CreateStategraphDef(
      _fbb,
      animation_stategraph ? _fbb.CreateString(animation_stategraph) : 0,
      initial_state);
}

}  // namespace lull

#endif  // FLATBUFFERS_GENERATED_STATEGRAPHDEF_LULL_H_
