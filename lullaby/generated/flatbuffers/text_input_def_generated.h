// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TEXTINPUTDEF_LULL_H_
#define FLATBUFFERS_GENERATED_TEXTINPUTDEF_LULL_H_

#include "flatbuffers/flatbuffers.h"

#include "common_generated.h"

namespace lull {

struct TextInputDef;

/// Configures the entity to accept text input.
struct TextInputDef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.TextInputDef";
  }
  enum {
    VT_ACTIVATE_IMMEDIATELY = 4,
    VT_DEACTIVATE_ON_ACCEPT = 6,
    VT_HINT = 8,
    VT_HINT_COLOR = 10,
    VT_COMPOSING_ENTITY = 12,
    VT_COMPOSING_DISTANCE = 14,
    VT_COMPOSING_THICKNESS = 16,
    VT_CARET_ENTITY = 18,
    VT_IS_CLIPPED = 20
  };
  /// Makes the text input active on startup
  bool activate_immediately() const {
    return GetField<uint8_t>(VT_ACTIVATE_IMMEDIATELY, 0) != 0;
  }
  /// Makes the text input inactive on text commit
  bool deactivate_on_accept() const {
    return GetField<uint8_t>(VT_DEACTIVATE_ON_ACCEPT, 0) != 0;
  }
  /// The initial text before user input
  const flatbuffers::String *hint() const {
    return GetPointer<const flatbuffers::String *>(VT_HINT);
  }
  /// The color of the above hint string; by default this will match whatever
  /// is specified in the RenderDef.
  const Color *hint_color() const {
    return GetStruct<const Color *>(VT_HINT_COLOR);
  }
  /// The blueprint to create the composing indicator entity.
  const flatbuffers::String *composing_entity() const {
    return GetPointer<const flatbuffers::String *>(VT_COMPOSING_ENTITY);
  }
  /// The vertical distance below the baseline of the composing indicator.
  float composing_distance() const {
    return GetField<float>(VT_COMPOSING_DISTANCE, 0.0f);
  }
  /// The vertical thickness of the composing indicator.
  float composing_thickness() const {
    return GetField<float>(VT_COMPOSING_THICKNESS, 0.0f);
  }
  /// The blueprint to create caret entity
  const flatbuffers::String *caret_entity() const {
    return GetPointer<const flatbuffers::String *>(VT_CARET_ENTITY);
  }
  /// Makes the text input always visible against parent entity's clip box.
  /// This currently only works for single line text with horizontal alignment
  /// = Left.
  bool is_clipped() const {
    return GetField<uint8_t>(VT_IS_CLIPPED, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ACTIVATE_IMMEDIATELY) &&
           VerifyField<uint8_t>(verifier, VT_DEACTIVATE_ON_ACCEPT) &&
           VerifyOffset(verifier, VT_HINT) &&
           verifier.Verify(hint()) &&
           VerifyField<Color>(verifier, VT_HINT_COLOR) &&
           VerifyOffset(verifier, VT_COMPOSING_ENTITY) &&
           verifier.Verify(composing_entity()) &&
           VerifyField<float>(verifier, VT_COMPOSING_DISTANCE) &&
           VerifyField<float>(verifier, VT_COMPOSING_THICKNESS) &&
           VerifyOffset(verifier, VT_CARET_ENTITY) &&
           verifier.Verify(caret_entity()) &&
           VerifyField<uint8_t>(verifier, VT_IS_CLIPPED) &&
           verifier.EndTable();
  }
};

struct TextInputDefBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_activate_immediately(bool activate_immediately) {
    fbb_.AddElement<uint8_t>(TextInputDef::VT_ACTIVATE_IMMEDIATELY, static_cast<uint8_t>(activate_immediately), 0);
  }
  void add_deactivate_on_accept(bool deactivate_on_accept) {
    fbb_.AddElement<uint8_t>(TextInputDef::VT_DEACTIVATE_ON_ACCEPT, static_cast<uint8_t>(deactivate_on_accept), 0);
  }
  void add_hint(flatbuffers::Offset<flatbuffers::String> hint) {
    fbb_.AddOffset(TextInputDef::VT_HINT, hint);
  }
  void add_hint_color(const Color *hint_color) {
    fbb_.AddStruct(TextInputDef::VT_HINT_COLOR, hint_color);
  }
  void add_composing_entity(flatbuffers::Offset<flatbuffers::String> composing_entity) {
    fbb_.AddOffset(TextInputDef::VT_COMPOSING_ENTITY, composing_entity);
  }
  void add_composing_distance(float composing_distance) {
    fbb_.AddElement<float>(TextInputDef::VT_COMPOSING_DISTANCE, composing_distance, 0.0f);
  }
  void add_composing_thickness(float composing_thickness) {
    fbb_.AddElement<float>(TextInputDef::VT_COMPOSING_THICKNESS, composing_thickness, 0.0f);
  }
  void add_caret_entity(flatbuffers::Offset<flatbuffers::String> caret_entity) {
    fbb_.AddOffset(TextInputDef::VT_CARET_ENTITY, caret_entity);
  }
  void add_is_clipped(bool is_clipped) {
    fbb_.AddElement<uint8_t>(TextInputDef::VT_IS_CLIPPED, static_cast<uint8_t>(is_clipped), 0);
  }
  explicit TextInputDefBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TextInputDefBuilder &operator=(const TextInputDefBuilder &);
  flatbuffers::Offset<TextInputDef> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TextInputDef>(end);
    return o;
  }
};

inline flatbuffers::Offset<TextInputDef> CreateTextInputDef(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool activate_immediately = false,
    bool deactivate_on_accept = false,
    flatbuffers::Offset<flatbuffers::String> hint = 0,
    const Color *hint_color = 0,
    flatbuffers::Offset<flatbuffers::String> composing_entity = 0,
    float composing_distance = 0.0f,
    float composing_thickness = 0.0f,
    flatbuffers::Offset<flatbuffers::String> caret_entity = 0,
    bool is_clipped = false) {
  TextInputDefBuilder builder_(_fbb);
  builder_.add_caret_entity(caret_entity);
  builder_.add_composing_thickness(composing_thickness);
  builder_.add_composing_distance(composing_distance);
  builder_.add_composing_entity(composing_entity);
  builder_.add_hint_color(hint_color);
  builder_.add_hint(hint);
  builder_.add_is_clipped(is_clipped);
  builder_.add_deactivate_on_accept(deactivate_on_accept);
  builder_.add_activate_immediately(activate_immediately);
  return builder_.Finish();
}

inline flatbuffers::Offset<TextInputDef> CreateTextInputDefDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool activate_immediately = false,
    bool deactivate_on_accept = false,
    const char *hint = nullptr,
    const Color *hint_color = 0,
    const char *composing_entity = nullptr,
    float composing_distance = 0.0f,
    float composing_thickness = 0.0f,
    const char *caret_entity = nullptr,
    bool is_clipped = false) {
  return lull::CreateTextInputDef(
      _fbb,
      activate_immediately,
      deactivate_on_accept,
      hint ? _fbb.CreateString(hint) : 0,
      hint_color,
      composing_entity ? _fbb.CreateString(composing_entity) : 0,
      composing_distance,
      composing_thickness,
      caret_entity ? _fbb.CreateString(caret_entity) : 0,
      is_clipped);
}

inline const lull::TextInputDef *GetTextInputDef(const void *buf) {
  return flatbuffers::GetRoot<lull::TextInputDef>(buf);
}

inline bool VerifyTextInputDefBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<lull::TextInputDef>(nullptr);
}

inline void FinishTextInputDefBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<lull::TextInputDef> root) {
  fbb.Finish(root);
}

}  // namespace lull

#endif  // FLATBUFFERS_GENERATED_TEXTINPUTDEF_LULL_H_
