// Autogenerated code.  Do not edit.
#ifndef _LULLABY_LULLABY_GENERATED_PHYSICS_SHAPES_GENERATED_H_
#define _LULLABY_LULLABY_GENERATED_PHYSICS_SHAPES_GENERATED_H_

#include <type_traits>
#include <memory>
#include "flatbuffers/physics_shapes_generated.h"
#include "lullaby/util/color.h"
#include "lullaby/util/common_types.h"
#include "lullaby/util/math.h"
#include "lullaby/util/optional.h"
#include "lullaby/util/typeid.h"
#include "common_generated.h"

namespace lull {
class PhysicsBoxShapeT;
class PhysicsSphereShapeT;
class PhysicsShapePrimitiveT;
class PhysicsShapePartT;
class PhysicsBoxShapeT {
 public:
  using FlatBufferType = PhysicsBoxShape;

  PhysicsBoxShapeT() {}

  mathfu::vec3 half_dimensions = {0.f, 0.f, 0.f};

  template <typename Archive>
  void SerializeFlatbuffer(Archive archive);
};

class PhysicsSphereShapeT {
 public:
  using FlatBufferType = PhysicsSphereShape;

  PhysicsSphereShapeT() {}

  float radius = 0.0f;

  template <typename Archive>
  void SerializeFlatbuffer(Archive archive);
};

class PhysicsShapePrimitiveT {
 public:
  using FlatBufferType = PhysicsShapePrimitive;
  static const uint8_t kNone = PhysicsShapePrimitive_NONE;

  PhysicsShapePrimitiveT() {}
  ~PhysicsShapePrimitiveT() { reset(); }

  PhysicsShapePrimitiveT(const PhysicsShapePrimitiveT& rhs) { assign(rhs); }
  PhysicsShapePrimitiveT& operator=(const PhysicsShapePrimitiveT& rhs) {
    assign(rhs);
    return *this;
  }

  void reset();

  FlatBufferType type() const {
    return type_;
  }

  template <typename T>
  T* get() {
    return type_ == get_type<T>() ?
        reinterpret_cast<T*>(&data_) : nullptr;
  }

  template <typename T>
  const T* get() const {
    return type_ == get_type<T>() ?
        reinterpret_cast<const T*>(&data_) : nullptr;
  }

  template <typename T>
  T* set();

  template <typename Archive>
  void SerializeFlatbuffer(FlatBufferType type, Archive archive);

 private:
  void assign(const PhysicsShapePrimitiveT& rhs);

  template <typename T>
  void destroy() {
    reinterpret_cast<T*>(&data_)->~T();
  }

  template <typename T>
  static FlatBufferType get_type() {
    return PhysicsShapePrimitive_NONE;
  }

  template <typename T>
  using Store = std::aligned_storage<sizeof(T), alignof(T)>;
  union Buffer {
    Store<lull::PhysicsBoxShapeT>::type PhysicsBoxShape_;
    Store<lull::PhysicsSphereShapeT>::type PhysicsSphereShape_;
  };
  Buffer data_;
  FlatBufferType type_ = PhysicsShapePrimitive_NONE;
};

class PhysicsShapePartT {
 public:
  using FlatBufferType = PhysicsShapePart;

  PhysicsShapePartT() {}

  lull::PhysicsShapePrimitiveT shape;
  lull::Optional<mathfu::vec3> translation;
  lull::Optional<mathfu::vec3> rotation;
  lull::Optional<mathfu::vec3> scale;

  template <typename Archive>
  void SerializeFlatbuffer(Archive archive);
};

template <typename Archive>
void PhysicsBoxShapeT::SerializeFlatbuffer(Archive archive) {
  archive.NativeStruct(&half_dimensions, 4);
}

template <typename Archive>
void PhysicsSphereShapeT::SerializeFlatbuffer(Archive archive) {
  archive.Scalar(&radius, 4, 0.0f);
}

inline void PhysicsShapePrimitiveT::reset() {
  switch (type_) {
    case PhysicsShapePrimitive_PhysicsBoxShape: {
      destroy<lull::PhysicsBoxShapeT>();
      break;
    }
    case PhysicsShapePrimitive_PhysicsSphereShape: {
      destroy<lull::PhysicsSphereShapeT>();
      break;
    }
    default:
      break;
  }
  type_ = PhysicsShapePrimitive_NONE;
}

inline void PhysicsShapePrimitiveT::assign(const PhysicsShapePrimitiveT& rhs) {
  reset();
  switch (rhs.type_) {
    case PhysicsShapePrimitive_PhysicsBoxShape: {
      *set<lull::PhysicsBoxShapeT>() = *rhs.get<lull::PhysicsBoxShapeT>();
      break;
    }
    case PhysicsShapePrimitive_PhysicsSphereShape: {
      *set<lull::PhysicsSphereShapeT>() = *rhs.get<lull::PhysicsSphereShapeT>();
      break;
    }
    default:
      break;
  }
}

template <typename T>
T* PhysicsShapePrimitiveT::set() {
  reset();
  type_ = get_type<T>();
  if (type_ != kNone) {
    return new (&data_) T();
  }
  return nullptr;
}

template <>
inline PhysicsShapePrimitive PhysicsShapePrimitiveT::get_type<lull::PhysicsBoxShapeT>() {
  return PhysicsShapePrimitive_PhysicsBoxShape;
}

template <>
inline PhysicsShapePrimitive PhysicsShapePrimitiveT::get_type<lull::PhysicsSphereShapeT>() {
  return PhysicsShapePrimitive_PhysicsSphereShape;
}


template <typename Archive>
void PhysicsShapePrimitiveT::SerializeFlatbuffer(FlatBufferType type, Archive archive) {
  switch (type) {
    case PhysicsShapePrimitive_PhysicsBoxShape: {
      if (archive.IsDestructive()) {
        set<lull::PhysicsBoxShapeT>()->SerializeFlatbuffer(archive);
      } else {
        get<lull::PhysicsBoxShapeT>()->SerializeFlatbuffer(archive);
      }
      break;
    }
    case PhysicsShapePrimitive_PhysicsSphereShape: {
      if (archive.IsDestructive()) {
        set<lull::PhysicsSphereShapeT>()->SerializeFlatbuffer(archive);
      } else {
        get<lull::PhysicsSphereShapeT>()->SerializeFlatbuffer(archive);
      }
      break;
    }
    default:
      if (archive.IsDestructive()) {
        reset();
      }
      break;
  }
}

template <typename Archive>
void PhysicsShapePartT::SerializeFlatbuffer(Archive archive) {
  archive.Union(&shape, 6, lull::PhysicsShapePrimitiveT::kNone);
  archive.NativeStruct(&translation, 8);
  archive.NativeStruct(&rotation, 10);
  archive.NativeStruct(&scale, 12);
}

}  // namespace lull

LULLABY_SETUP_TYPEID(lull::PhysicsBoxShapeT);
LULLABY_SETUP_TYPEID(lull::PhysicsSphereShapeT);
LULLABY_SETUP_TYPEID(lull::PhysicsShapePrimitiveT);
LULLABY_SETUP_TYPEID(lull::PhysicsShapePartT);

#endif  // _LULLABY_LULLABY_GENERATED_PHYSICS_SHAPES_GENERATED_H_

