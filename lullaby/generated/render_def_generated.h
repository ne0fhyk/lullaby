// Autogenerated code.  Do not edit.
#ifndef _LULLABY_LULLABY_GENERATED_RENDER_DEF_GENERATED_H_
#define _LULLABY_LULLABY_GENERATED_RENDER_DEF_GENERATED_H_

#include <type_traits>
#include <memory>
#include "flatbuffers/render_def_generated.h"
#include "lullaby/util/common_types.h"
#include "lullaby/util/color.h"
#include "lullaby/util/math.h"
#include "lullaby/util/optional.h"
#include "lullaby/util/typeid.h"
#include "common_generated.h"

namespace lull {
class QuadDefT;
class UniformDefT;
class FontDefT;
class RenderDefT;
class QuadDefT {
 public:
  using FlatBufferType = QuadDef;

  QuadDefT() {}

  float size_x = 0.0f;
  float size_y = 0.0f;
  int32_t verts_x = 0;
  int32_t verts_y = 0;
  bool has_uv = 0;
  float corner_radius = 0.0f;
  int32_t corner_verts = 0;

  template <typename Archive>
  void SerializeFlatbuffer(Archive archive);
};

class UniformDefT {
 public:
  using FlatBufferType = UniformDef;

  UniformDefT() {}

  std::string name;
  std::vector<float> float_value;
  int32_t dimension = 0;
  int32_t count = 1;

  template <typename Archive>
  void SerializeFlatbuffer(Archive archive);
};

class FontDefT {
 public:
  using FlatBufferType = FontDef;

  FontDefT() {}

  std::string font;
  int32_t size = 0;
  float edge_threshold = 0.5f;
  float edge_softness = 0.3f;
  float line_height_scale = 1.2f;
  lull::HorizontalAlignment horizontal_alignment = lull::HorizontalAlignment_Center;
  lull::VerticalAlignment vertical_alignment = lull::VerticalAlignment_Center;
  int32_t rect_width = 0;
  int32_t rect_height = 0;
  std::string ellipsis;
  std::vector<std::string> fonts;
  bool wrap_content = 0;
  float kerning_scale = 1.0f;
  bool parse_and_strip_html = 0;
  lull::Color4ub html_link_color;

  template <typename Archive>
  void SerializeFlatbuffer(Archive archive);
};

class RenderDefT {
 public:
  using FlatBufferType = RenderDef;

  RenderDefT() {}

  lull::RenderPass pass = lull::RenderPass_Main;
  std::string mesh;
  lull::QuadDefT quad;
  std::string shader;
  std::string texture;
  bool create_mips = 0;
  std::string text;
  lull::Optional<lull::FontDefT> font;
  lull::Color4ub color;
  std::string color_hex;
  std::vector<lull::UniformDefT> uniforms;
  int32_t sort_order_offset = 0;
  std::string shape_id;
  bool hidden = 0;
  bool external_texture = 0;
  std::vector<std::string> textures;
  lull::HashValue id = 0;

  template <typename Archive>
  void SerializeFlatbuffer(Archive archive);
};

template <typename Archive>
void QuadDefT::SerializeFlatbuffer(Archive archive) {
  archive.Scalar(&size_x, 0, 0.0f);
  archive.Scalar(&size_y, 4, 0.0f);
  archive.Scalar(&verts_x, 8, 0);
  archive.Scalar(&verts_y, 12, 0);
  archive.Scalar(&has_uv, 16, 0);
  archive.Scalar(&corner_radius, 20, 0.0f);
  archive.Scalar(&corner_verts, 24, 0);
}

template <typename Archive>
void UniformDefT::SerializeFlatbuffer(Archive archive) {
  archive.String(&name, 4);
  archive.VectorOfScalars(&float_value, 6);
  archive.Scalar(&dimension, 8, 0);
  archive.Scalar(&count, 10, 1);
}

template <typename Archive>
void FontDefT::SerializeFlatbuffer(Archive archive) {
  archive.String(&font, 4);
  archive.String(&ellipsis, 22);
  archive.VectorOfStrings(&fonts, 24);
  archive.Scalar(&size, 6, 0);
  archive.Scalar(&edge_threshold, 8, 0.5f);
  archive.Scalar(&edge_softness, 10, 0.3f);
  archive.Scalar(&line_height_scale, 12, 1.2f);
  int32_t _horizontal_alignment = static_cast<int32_t>(horizontal_alignment);
  archive.Scalar(&_horizontal_alignment, 14, lull::HorizontalAlignment_Center);
  horizontal_alignment = static_cast<lull::HorizontalAlignment>(_horizontal_alignment);
  int32_t _vertical_alignment = static_cast<int32_t>(vertical_alignment);
  archive.Scalar(&_vertical_alignment, 16, lull::VerticalAlignment_Center);
  vertical_alignment = static_cast<lull::VerticalAlignment>(_vertical_alignment);
  archive.Scalar(&rect_width, 18, 0);
  archive.Scalar(&rect_height, 20, 0);
  archive.Scalar(&wrap_content, 26, 0);
  archive.Scalar(&kerning_scale, 28, 1.0f);
  archive.Scalar(&parse_and_strip_html, 30, 0);
  archive.NativeStruct(&html_link_color, 32);
}

template <typename Archive>
void RenderDefT::SerializeFlatbuffer(Archive archive) {
  archive.String(&mesh, 6);
  archive.String(&shader, 10);
  archive.String(&texture, 12);
  archive.String(&text, 16);
  archive.Table(&font, 18);
  archive.String(&color_hex, 22);
  archive.VectorOfTables(&uniforms, 24);
  archive.String(&shape_id, 28);
  archive.VectorOfStrings(&textures, 34);
  int32_t _pass = static_cast<int32_t>(pass);
  archive.Scalar(&_pass, 4, lull::RenderPass_Main);
  pass = static_cast<lull::RenderPass>(_pass);
  archive.Struct(&quad, 8);
  archive.Scalar(&create_mips, 14, 0);
  archive.NativeStruct(&color, 20);
  archive.Scalar(&sort_order_offset, 26, 0);
  archive.Scalar(&hidden, 30, 0);
  archive.Scalar(&external_texture, 32, 0);
  archive.Scalar(&id, 36, 0);
}

}  // namespace lull

LULLABY_SETUP_TYPEID(lull::RenderPass);
LULLABY_SETUP_TYPEID(lull::HorizontalAlignment);
LULLABY_SETUP_TYPEID(lull::VerticalAlignment);
LULLABY_SETUP_TYPEID(lull::QuadDefT);
LULLABY_SETUP_TYPEID(lull::UniformDefT);
LULLABY_SETUP_TYPEID(lull::FontDefT);
LULLABY_SETUP_TYPEID(lull::RenderDefT);

#endif  // _LULLABY_LULLABY_GENERATED_RENDER_DEF_GENERATED_H_

