// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_COMMON_LULL_H_
#define FLATBUFFERS_GENERATED_COMMON_LULL_H_

#include "flatbuffers/flatbuffers.h"

namespace lull {

struct Vec2;

struct Vec2i;

struct Vec3;

struct Vec4;

struct Quat;

struct Rect;

struct Color;

struct AabbDef;

struct ArcDef;

/// The directions a layout will grow in.
/// This controls the ordering of elements within wrapping rows, but not the
/// horizontal alignment of those rows as a whole (which is controlled by
/// LayoutHorizontalAlignment).
enum LayoutFillOrder {
  /// The first entity is added leftmost, and subsequent entities go to the
  /// right (and then down if wrapping is enabled).
  LayoutFillOrder_RightDown = 0  /// The first entity is added rightmost, and subsequent entities go to the
  /// left (and then down if wrapping is enabled).
,
  LayoutFillOrder_LeftDown = 1  /// The first entity is added leftmost, and subsequent entities go down
  /// (and then right if wrapping is enabled).
,
  LayoutFillOrder_DownRight = 2  /// The first entity is added rightmost, and subsequent entities go down
  /// (and then left if wrapping is enabled).
,
  LayoutFillOrder_DownLeft = 3  /// The first entity is added leftmost, and subsequent entities go to the
  /// right (and then up if wrapping is enabled).
,
  LayoutFillOrder_RightUp = 4  /// The first entity is added rightmost, and subsequent entities go to the
  /// left (and then up if wrapping is enabled).
,
  LayoutFillOrder_LeftUp = 5  /// The first entity is added leftmost, and subsequent entities go up
  /// (and then right if wrapping is enabled).
,
  LayoutFillOrder_UpRight = 6  /// The first entity is added rightmost, and subsequent entities go up
  /// (and then left if wrapping is enabled).
,
  LayoutFillOrder_UpLeft = 7,
  LayoutFillOrder_MIN = LayoutFillOrder_RightDown,
  LayoutFillOrder_MAX = LayoutFillOrder_UpLeft
};

inline const char **EnumNamesLayoutFillOrder() {
  static const char *names[] = {
    "RightDown",
    "LeftDown",
    "DownRight",
    "DownLeft",
    "RightUp",
    "LeftUp",
    "UpRight",
    "UpLeft",
    nullptr
  };
  return names;
}

inline const char *EnumNameLayoutFillOrder(LayoutFillOrder e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesLayoutFillOrder()[index];
}

/// The anchor at which the entities will be aligned relative to the canvas.
enum LayoutHorizontalAlignment {
  /// The left border of the leftmost element will align to the left side of the
  /// canvas.
  LayoutHorizontalAlignment_Left = 0  /// The layout will be centered horizontally on the canvas.
,
  LayoutHorizontalAlignment_Center = 1  /// The right border of the rightmost element will align to the right side of
  /// the canvas.
,
  LayoutHorizontalAlignment_Right = 2,
  LayoutHorizontalAlignment_MIN = LayoutHorizontalAlignment_Left,
  LayoutHorizontalAlignment_MAX = LayoutHorizontalAlignment_Right
};

inline const char **EnumNamesLayoutHorizontalAlignment() {
  static const char *names[] = {
    "Left",
    "Center",
    "Right",
    nullptr
  };
  return names;
}

inline const char *EnumNameLayoutHorizontalAlignment(LayoutHorizontalAlignment e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesLayoutHorizontalAlignment()[index];
}

/// The anchor at which the entities will be aligned *within* each row.
/// Note that rows collectively are still top aligned relative to the canvas.
/// To center align within the canvas, add a placeholder child entity with the
/// same height as the canvas.
enum LayoutVerticalAlignment {
  /// Each entity will align to the top of its row in the layout.
  LayoutVerticalAlignment_Top = 0  /// Each entity will be centered within its row.
,
  LayoutVerticalAlignment_Center = 1  /// Each entity will align to the bottom of its row.
,
  LayoutVerticalAlignment_Bottom = 2,
  LayoutVerticalAlignment_MIN = LayoutVerticalAlignment_Top,
  LayoutVerticalAlignment_MAX = LayoutVerticalAlignment_Bottom
};

inline const char **EnumNamesLayoutVerticalAlignment() {
  static const char *names[] = {
    "Top",
    "Center",
    "Bottom",
    nullptr
  };
  return names;
}

inline const char *EnumNameLayoutVerticalAlignment(LayoutVerticalAlignment e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesLayoutVerticalAlignment()[index];
}

/// Potential Input Devices (matches enum in
/// vr/internal/lullaby/src/base/input_manager.h)
enum DeviceType {
  DeviceType_Hmd = 0,
  DeviceType_Mouse = 1,
  DeviceType_Keyboard = 2,
  DeviceType_Controller = 3,
  DeviceType_Controller2 = 4,
  DeviceType_Hand = 5,
  DeviceType_MIN = DeviceType_Hmd,
  DeviceType_MAX = DeviceType_Hand
};

inline const char **EnumNamesDeviceType() {
  static const char *names[] = {
    "Hmd",
    "Mouse",
    "Keyboard",
    "Controller",
    "Controller2",
    "Hand",
    nullptr
  };
  return names;
}

inline const char *EnumNameDeviceType(DeviceType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesDeviceType()[index];
}

MANUALLY_ALIGNED_STRUCT(4) Vec2 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.Vec2";
  }
  Vec2() {
    memset(this, 0, sizeof(Vec2));
  }
  Vec2(const Vec2 &_o) {
    memcpy(this, &_o, sizeof(Vec2));
  }
  Vec2(float _x, float _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
STRUCT_END(Vec2, 8);

MANUALLY_ALIGNED_STRUCT(4) Vec2i FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t x_;
  int32_t y_;

 public:
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.Vec2i";
  }
  Vec2i() {
    memset(this, 0, sizeof(Vec2i));
  }
  Vec2i(const Vec2i &_o) {
    memcpy(this, &_o, sizeof(Vec2i));
  }
  Vec2i(int32_t _x, int32_t _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  int32_t x() const {
    return flatbuffers::EndianScalar(x_);
  }
  int32_t y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
STRUCT_END(Vec2i, 8);

MANUALLY_ALIGNED_STRUCT(4) Vec3 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.Vec3";
  }
  Vec3() {
    memset(this, 0, sizeof(Vec3));
  }
  Vec3(const Vec3 &_o) {
    memcpy(this, &_o, sizeof(Vec3));
  }
  Vec3(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
STRUCT_END(Vec3, 12);

MANUALLY_ALIGNED_STRUCT(4) Vec4 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float w_;

 public:
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.Vec4";
  }
  Vec4() {
    memset(this, 0, sizeof(Vec4));
  }
  Vec4(const Vec4 &_o) {
    memcpy(this, &_o, sizeof(Vec4));
  }
  Vec4(float _x, float _y, float _z, float _w)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)),
        w_(flatbuffers::EndianScalar(_w)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
  float w() const {
    return flatbuffers::EndianScalar(w_);
  }
};
STRUCT_END(Vec4, 16);

MANUALLY_ALIGNED_STRUCT(4) Quat FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float w_;

 public:
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.Quat";
  }
  Quat() {
    memset(this, 0, sizeof(Quat));
  }
  Quat(const Quat &_o) {
    memcpy(this, &_o, sizeof(Quat));
  }
  Quat(float _x, float _y, float _z, float _w)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)),
        w_(flatbuffers::EndianScalar(_w)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
  float w() const {
    return flatbuffers::EndianScalar(w_);
  }
};
STRUCT_END(Quat, 16);

MANUALLY_ALIGNED_STRUCT(4) Rect FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float w_;
  float h_;

 public:
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.Rect";
  }
  Rect() {
    memset(this, 0, sizeof(Rect));
  }
  Rect(const Rect &_o) {
    memcpy(this, &_o, sizeof(Rect));
  }
  Rect(float _x, float _y, float _w, float _h)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        w_(flatbuffers::EndianScalar(_w)),
        h_(flatbuffers::EndianScalar(_h)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float w() const {
    return flatbuffers::EndianScalar(w_);
  }
  float h() const {
    return flatbuffers::EndianScalar(h_);
  }
};
STRUCT_END(Rect, 16);

MANUALLY_ALIGNED_STRUCT(4) Color FLATBUFFERS_FINAL_CLASS {
 private:
  float r_;
  float g_;
  float b_;
  float a_;

 public:
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.Color";
  }
  Color() {
    memset(this, 0, sizeof(Color));
  }
  Color(const Color &_o) {
    memcpy(this, &_o, sizeof(Color));
  }
  Color(float _r, float _g, float _b, float _a)
      : r_(flatbuffers::EndianScalar(_r)),
        g_(flatbuffers::EndianScalar(_g)),
        b_(flatbuffers::EndianScalar(_b)),
        a_(flatbuffers::EndianScalar(_a)) {
  }
  float r() const {
    return flatbuffers::EndianScalar(r_);
  }
  float g() const {
    return flatbuffers::EndianScalar(g_);
  }
  float b() const {
    return flatbuffers::EndianScalar(b_);
  }
  float a() const {
    return flatbuffers::EndianScalar(a_);
  }
};
STRUCT_END(Color, 16);

MANUALLY_ALIGNED_STRUCT(4) AabbDef FLATBUFFERS_FINAL_CLASS {
 private:
  Vec3 min_;
  Vec3 max_;

 public:
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.AabbDef";
  }
  AabbDef() {
    memset(this, 0, sizeof(AabbDef));
  }
  AabbDef(const AabbDef &_o) {
    memcpy(this, &_o, sizeof(AabbDef));
  }
  AabbDef(const Vec3 &_min, const Vec3 &_max)
      : min_(_min),
        max_(_max) {
  }
  const Vec3 &min() const {
    return min_;
  }
  const Vec3 &max() const {
    return max_;
  }
};
STRUCT_END(AabbDef, 24);

/// ArcDef defines a portion of a circulur annulus.
MANUALLY_ALIGNED_STRUCT(4) ArcDef FLATBUFFERS_FINAL_CLASS {
 private:
  float start_angle_;
  float angle_size_;
  float inner_radius_;
  float outer_radius_;
  int32_t num_samples_;

 public:
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.ArcDef";
  }
  ArcDef() {
    memset(this, 0, sizeof(ArcDef));
  }
  ArcDef(const ArcDef &_o) {
    memcpy(this, &_o, sizeof(ArcDef));
  }
  ArcDef(float _start_angle, float _angle_size, float _inner_radius, float _outer_radius, int32_t _num_samples)
      : start_angle_(flatbuffers::EndianScalar(_start_angle)),
        angle_size_(flatbuffers::EndianScalar(_angle_size)),
        inner_radius_(flatbuffers::EndianScalar(_inner_radius)),
        outer_radius_(flatbuffers::EndianScalar(_outer_radius)),
        num_samples_(flatbuffers::EndianScalar(_num_samples)) {
  }
  /// The angle (in radians) in which the start of the arc should be poised at.
  /// 0 = vertical [0,1]. PI = [0,-1], PI/2 = [1,0].
  float start_angle() const {
    return flatbuffers::EndianScalar(start_angle_);
  }
  /// Size of the arc measured in radians. PI = half circle, 2 PI = full circle.
  float angle_size() const {
    return flatbuffers::EndianScalar(angle_size_);
  }
  /// Inner radius of the arc.
  float inner_radius() const {
    return flatbuffers::EndianScalar(inner_radius_);
  }
  /// Outer radius of the arc.
  float outer_radius() const {
    return flatbuffers::EndianScalar(outer_radius_);
  }
  /// Number of samples used for drawing the arc.
  int32_t num_samples() const {
    return flatbuffers::EndianScalar(num_samples_);
  }
};
STRUCT_END(ArcDef, 20);

}  // namespace lull

#endif  // FLATBUFFERS_GENERATED_COMMON_LULL_H_
