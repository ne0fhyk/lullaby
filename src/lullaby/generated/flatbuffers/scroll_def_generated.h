// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SCROLLDEF_LULL_H_
#define FLATBUFFERS_GENERATED_SCROLLDEF_LULL_H_

#include "flatbuffers/flatbuffers.h"

#include "common_generated.h"

namespace lull {

struct ScrollDef;

struct ScrollSnapToGridDef;

struct ScrollSnapToGrandchildrenDef;

struct ScrollContentLayoutDef;

/// Adds a scroll view to the entity.  Scroll views are controlled by touchpad
/// input to change the position of children.
struct ScrollDef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.ScrollDef";
  }
  enum {
    VT_CONTENT_BOUNDS = 4,
    VT_TOUCH_SENSITIVITY = 6,
    VT_TOUCH_MOMENTUM_MS = 8,
    VT_ACTIVE_PRIORITY = 10,
    VT_DRAG_BORDER = 12,
    VT_DRAG_MOMENTUM_MS = 14
  };
  /// The virtual size of the entire field of content. The content location is
  /// assumed to start at the origin.  (Note: the z-values are ignored since
  /// scrolling only happens in 2-dimensions.)
  const lull::AabbDef *content_bounds() const {
    return GetStruct<const lull::AabbDef *>(VT_CONTENT_BOUNDS);
  }
  /// Defines how fast the scroll view will move relative to the touch pad
  /// input. A value of 0 will prevent scrolling in the specified dimension.
  const lull::Vec2 *touch_sensitivity() const {
    return GetStruct<const lull::Vec2 *>(VT_TOUCH_SENSITIVITY);
  }
  /// Defines (in milliseconds) how long the touch momentum is carried when the
  /// touch is released.  Must be >= 0.
  int32_t touch_momentum_ms() const {
    return GetField<int32_t>(VT_TOUCH_MOMENTUM_MS, 250);
  }
  /// By default, scroll views are only active if the entity is being hovered.
  /// A positive, non-zero priority will force the scroll view to be active
  /// regardless of hover state.
  int32_t active_priority() const {
    return GetField<int32_t>(VT_ACTIVE_PRIORITY, 0);
  }
  /// If defined, this allows the scroll view to be dragged past its content
  /// bounds with increasing resistance.
  const lull::Vec2 *drag_border() const {
    return GetStruct<const lull::Vec2 *>(VT_DRAG_BORDER);
  }
  /// Same as touch_momentum_ms, but for dragging.  Must be >= 0.
  int32_t drag_momentum_ms() const {
    return GetField<int32_t>(VT_DRAG_MOMENTUM_MS, 50);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<lull::AabbDef>(verifier, VT_CONTENT_BOUNDS) &&
           VerifyField<lull::Vec2>(verifier, VT_TOUCH_SENSITIVITY) &&
           VerifyField<int32_t>(verifier, VT_TOUCH_MOMENTUM_MS) &&
           VerifyField<int32_t>(verifier, VT_ACTIVE_PRIORITY) &&
           VerifyField<lull::Vec2>(verifier, VT_DRAG_BORDER) &&
           VerifyField<int32_t>(verifier, VT_DRAG_MOMENTUM_MS) &&
           verifier.EndTable();
  }
};

struct ScrollDefBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_content_bounds(const lull::AabbDef *content_bounds) {
    fbb_.AddStruct(ScrollDef::VT_CONTENT_BOUNDS, content_bounds);
  }
  void add_touch_sensitivity(const lull::Vec2 *touch_sensitivity) {
    fbb_.AddStruct(ScrollDef::VT_TOUCH_SENSITIVITY, touch_sensitivity);
  }
  void add_touch_momentum_ms(int32_t touch_momentum_ms) {
    fbb_.AddElement<int32_t>(ScrollDef::VT_TOUCH_MOMENTUM_MS, touch_momentum_ms, 250);
  }
  void add_active_priority(int32_t active_priority) {
    fbb_.AddElement<int32_t>(ScrollDef::VT_ACTIVE_PRIORITY, active_priority, 0);
  }
  void add_drag_border(const lull::Vec2 *drag_border) {
    fbb_.AddStruct(ScrollDef::VT_DRAG_BORDER, drag_border);
  }
  void add_drag_momentum_ms(int32_t drag_momentum_ms) {
    fbb_.AddElement<int32_t>(ScrollDef::VT_DRAG_MOMENTUM_MS, drag_momentum_ms, 50);
  }
  ScrollDefBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ScrollDefBuilder &operator=(const ScrollDefBuilder &);
  flatbuffers::Offset<ScrollDef> Finish() {
    const auto end = fbb_.EndTable(start_, 6);
    auto o = flatbuffers::Offset<ScrollDef>(end);
    return o;
  }
};

inline flatbuffers::Offset<ScrollDef> CreateScrollDef(
    flatbuffers::FlatBufferBuilder &_fbb,
    const lull::AabbDef *content_bounds = 0,
    const lull::Vec2 *touch_sensitivity = 0,
    int32_t touch_momentum_ms = 250,
    int32_t active_priority = 0,
    const lull::Vec2 *drag_border = 0,
    int32_t drag_momentum_ms = 50) {
  ScrollDefBuilder builder_(_fbb);
  builder_.add_drag_momentum_ms(drag_momentum_ms);
  builder_.add_drag_border(drag_border);
  builder_.add_active_priority(active_priority);
  builder_.add_touch_momentum_ms(touch_momentum_ms);
  builder_.add_touch_sensitivity(touch_sensitivity);
  builder_.add_content_bounds(content_bounds);
  return builder_.Finish();
}

/// If added to an Entity with a scroll view (see ScrollDef above), this will
/// define a grid to which the scrolling will snap.
struct ScrollSnapToGridDef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.ScrollSnapToGridDef";
  }
  enum {
    VT_INTERVAL = 4
  };
  /// The space between grid points where the first grid point is at (0,0).
  /// Must be > (0,0)
  const lull::Vec2 *interval() const {
    return GetStruct<const lull::Vec2 *>(VT_INTERVAL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<lull::Vec2>(verifier, VT_INTERVAL) &&
           verifier.EndTable();
  }
};

struct ScrollSnapToGridDefBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_interval(const lull::Vec2 *interval) {
    fbb_.AddStruct(ScrollSnapToGridDef::VT_INTERVAL, interval);
  }
  ScrollSnapToGridDefBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ScrollSnapToGridDefBuilder &operator=(const ScrollSnapToGridDefBuilder &);
  flatbuffers::Offset<ScrollSnapToGridDef> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<ScrollSnapToGridDef>(end);
    return o;
  }
};

inline flatbuffers::Offset<ScrollSnapToGridDef> CreateScrollSnapToGridDef(
    flatbuffers::FlatBufferBuilder &_fbb,
    const lull::Vec2 *interval = 0) {
  ScrollSnapToGridDefBuilder builder_(_fbb);
  builder_.add_interval(interval);
  return builder_.Finish();
}

/// If added to an Entity with a scroll view (see ScrollDef above), this will
/// snap the scrolling to the grandchildren of the scroll view.  Grandchildren
/// are used since the children of the scroll view are directly controlled by
/// the scroll view and so snapping to the children will cause a conflict.
struct ScrollSnapToGrandchildrenDef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.ScrollSnapToGrandchildrenDef";
  }
  enum {
    VT_FLING_MULTIPLIER = 4
  };
  float fling_multiplier() const {
    return GetField<float>(VT_FLING_MULTIPLIER, 1.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_FLING_MULTIPLIER) &&
           verifier.EndTable();
  }
};

struct ScrollSnapToGrandchildrenDefBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fling_multiplier(float fling_multiplier) {
    fbb_.AddElement<float>(ScrollSnapToGrandchildrenDef::VT_FLING_MULTIPLIER, fling_multiplier, 1.0f);
  }
  ScrollSnapToGrandchildrenDefBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ScrollSnapToGrandchildrenDefBuilder &operator=(const ScrollSnapToGrandchildrenDefBuilder &);
  flatbuffers::Offset<ScrollSnapToGrandchildrenDef> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<ScrollSnapToGrandchildrenDef>(end);
    return o;
  }
};

inline flatbuffers::Offset<ScrollSnapToGrandchildrenDef> CreateScrollSnapToGrandchildrenDef(
    flatbuffers::FlatBufferBuilder &_fbb,
    float fling_multiplier = 1.0f) {
  ScrollSnapToGrandchildrenDefBuilder builder_(_fbb);
  builder_.add_fling_multiplier(fling_multiplier);
  return builder_.Finish();
}

/// If added to an Entity with a scroll view (see ScrollDef above), this will
/// automatically set the scroll view's content bounds to that of its child's
/// Aabb.
struct ScrollContentLayoutDef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.ScrollContentLayoutDef";
  }
  enum {
    VT_LEFT_PADDING = 4,
    VT_RIGHT_PADDING = 6,
    VT_TOP_PADDING = 8,
    VT_BOTTOM_PADDING = 10
  };
  /// Additional padding to be added to the content bounds.  By increasing (or
  /// decreasing) the content bounds, the amount of allowed scrolling can be
  /// controlled.
  float left_padding() const {
    return GetField<float>(VT_LEFT_PADDING, 0.0f);
  }
  float right_padding() const {
    return GetField<float>(VT_RIGHT_PADDING, 0.0f);
  }
  float top_padding() const {
    return GetField<float>(VT_TOP_PADDING, 0.0f);
  }
  float bottom_padding() const {
    return GetField<float>(VT_BOTTOM_PADDING, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_LEFT_PADDING) &&
           VerifyField<float>(verifier, VT_RIGHT_PADDING) &&
           VerifyField<float>(verifier, VT_TOP_PADDING) &&
           VerifyField<float>(verifier, VT_BOTTOM_PADDING) &&
           verifier.EndTable();
  }
};

struct ScrollContentLayoutDefBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_left_padding(float left_padding) {
    fbb_.AddElement<float>(ScrollContentLayoutDef::VT_LEFT_PADDING, left_padding, 0.0f);
  }
  void add_right_padding(float right_padding) {
    fbb_.AddElement<float>(ScrollContentLayoutDef::VT_RIGHT_PADDING, right_padding, 0.0f);
  }
  void add_top_padding(float top_padding) {
    fbb_.AddElement<float>(ScrollContentLayoutDef::VT_TOP_PADDING, top_padding, 0.0f);
  }
  void add_bottom_padding(float bottom_padding) {
    fbb_.AddElement<float>(ScrollContentLayoutDef::VT_BOTTOM_PADDING, bottom_padding, 0.0f);
  }
  ScrollContentLayoutDefBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ScrollContentLayoutDefBuilder &operator=(const ScrollContentLayoutDefBuilder &);
  flatbuffers::Offset<ScrollContentLayoutDef> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<ScrollContentLayoutDef>(end);
    return o;
  }
};

inline flatbuffers::Offset<ScrollContentLayoutDef> CreateScrollContentLayoutDef(
    flatbuffers::FlatBufferBuilder &_fbb,
    float left_padding = 0.0f,
    float right_padding = 0.0f,
    float top_padding = 0.0f,
    float bottom_padding = 0.0f) {
  ScrollContentLayoutDefBuilder builder_(_fbb);
  builder_.add_bottom_padding(bottom_padding);
  builder_.add_top_padding(top_padding);
  builder_.add_right_padding(right_padding);
  builder_.add_left_padding(left_padding);
  return builder_.Finish();
}

inline const lull::ScrollDef *GetScrollDef(const void *buf) {
  return flatbuffers::GetRoot<lull::ScrollDef>(buf);
}

inline bool VerifyScrollDefBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<lull::ScrollDef>(nullptr);
}

inline void FinishScrollDefBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<lull::ScrollDef> root) {
  fbb.Finish(root);
}

}  // namespace lull

#endif  // FLATBUFFERS_GENERATED_SCROLLDEF_LULL_H_
