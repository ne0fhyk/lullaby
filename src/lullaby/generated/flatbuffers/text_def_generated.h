// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TEXTDEF_LULL_H_
#define FLATBUFFERS_GENERATED_TEXTDEF_LULL_H_

#include "flatbuffers/flatbuffers.h"

#include "common_generated.h"
#include "render_def_generated.h"

namespace lull {

struct TextDef;

/// TextHtmlMode defines how HTML formatting is dealt with.
enum TextHtmlMode {
  /// Ignores any HTML formatting, leaving it visible in the text string.
  TextHtmlMode_Ignore = 0  /// Removes all HTML tags and ignores their contents.
,
  TextHtmlMode_RemoveTags = 1  /// Removes all HTML tags, extracting links to make them clickable.
,
  TextHtmlMode_ExtractLinks = 2,
  TextHtmlMode_MIN = TextHtmlMode_Ignore,
  TextHtmlMode_MAX = TextHtmlMode_ExtractLinks
};

inline const char **EnumNamesTextHtmlMode() {
  static const char *names[] = {
    "Ignore",
    "RemoveTags",
    "ExtractLinks",
    nullptr
  };
  return names;
}

inline const char *EnumNameTextHtmlMode(TextHtmlMode e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesTextHtmlMode()[index];
}

/// Defines if/how lines are automatically broken across lines.
enum TextWrapMode {
  /// Don't wrap lines.
  TextWrapMode_None = 0  /// Wraps text, preferring to break lines only between words.  If a single
  /// word is too wide, it will be broken without being hyphenated to remain
  /// in bounds.
,
  TextWrapMode_BetweenWords = 1  /// Wraps text, breaking eligible words by hyphenation.  This requires the
  /// locale and the hyphenation pattern directory to be set.  Hyphenation
  /// patterns are built into Android, but will need to be included on other
  /// platforms.
,
  TextWrapMode_Hyphenate = 2,
  TextWrapMode_MIN = TextWrapMode_None,
  TextWrapMode_MAX = TextWrapMode_Hyphenate
};

inline const char **EnumNamesTextWrapMode() {
  static const char *names[] = {
    "None",
    "BetweenWords",
    "Hyphenate",
    nullptr
  };
  return names;
}

inline const char *EnumNameTextWrapMode(TextWrapMode e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesTextWrapMode()[index];
}

/// Controls the reading direction of text.
enum TextDirection {
  TextDirection_UseSystemSetting = 0,
  TextDirection_LeftToRight = 1,
  TextDirection_RightToLeft = 2,
  TextDirection_MIN = TextDirection_UseSystemSetting,
  TextDirection_MAX = TextDirection_RightToLeft
};

inline const char **EnumNamesTextDirection() {
  static const char *names[] = {
    "UseSystemSetting",
    "LeftToRight",
    "RightToLeft",
    nullptr
  };
  return names;
}

inline const char *EnumNameTextDirection(TextDirection e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesTextDirection()[index];
}

/// Specifies information about the font used for text rendering in a RenderDef.
struct TextDef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.TextDef";
  }
  enum {
    VT_TEXT = 4,
    VT_FONTS = 6,
    VT_FONT_SIZE = 8,
    VT_LINE_HEIGHT = 10,
    VT_LINE_HEIGHT_SCALE = 12,
    VT_HORIZONTAL_ALIGNMENT = 14,
    VT_VERTICAL_ALIGNMENT = 16,
    VT_DIRECTION = 18,
    VT_BOUNDS = 20,
    VT_WRAP_MODE = 22,
    VT_ELLIPSIS = 24,
    VT_EDGE_SOFTNESS = 26,
    VT_KERNING_SCALE = 28,
    VT_HTML_MODE = 30,
    VT_LINK_TEXT_BLUEPRINT = 32,
    VT_LINK_UNDERLINE_BLUEPRINT = 34
  };
  /// Optional.  The unprocessed text string.  If a StringProcessor exists in
  /// the app, the result of ProcessString(text) will be rendered.
  /// Otherwise, |text| will be rendered.
  const flatbuffers::String *text() const {
    return GetPointer<const flatbuffers::String *>(VT_TEXT);
  }
  /// Required.  A list of fonts to use. Each font should contain suffix as
  /// well, such as ".ttf".  For flatui, fonts are selected with a fallback
  /// priority, and ".SystemFont" can be used to refer to system font.  For
  /// Ion backend, the first font in the list will be always used and the
  /// rest are simply ignored.
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *fonts() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_FONTS);
  }
  /// Required.  The font size, measured in meters from the top to bottom of
  /// each line (including any ascenders/descenders and leading).
  /// The height of the text bounding box is this value multiplied by the
  /// number of lines multiplied by line_height_scale.
  float font_size() const {
    return GetField<float>(VT_FONT_SIZE, 0.0f);
  }
  /// DEPRECATED; do not use.
  float line_height() const {
    return GetField<float>(VT_LINE_HEIGHT, 0.0f);
  }
  /// Optional.  The spacing between lines as a function of the font size.
  float line_height_scale() const {
    return GetField<float>(VT_LINE_HEIGHT_SCALE, 1.2f);
  }
  /// Optional.  How to align the text in the x direction (default = Center,
  /// can also be Left or Right).
  lull::HorizontalAlignment horizontal_alignment() const {
    return static_cast<lull::HorizontalAlignment>(GetField<int32_t>(VT_HORIZONTAL_ALIGNMENT, 1));
  }
  /// Optional.  How to align the text in the y direction (default = Baseline,
  /// can also be Top, Center, or Bottom).
  lull::VerticalAlignment vertical_alignment() const {
    return static_cast<lull::VerticalAlignment>(GetField<int32_t>(VT_VERTICAL_ALIGNMENT, 2));
  }
  /// Optional. How text should be displayed (default = UseSystemSetting,
  /// can also be LeftToRight and RightToLeft).
  TextDirection direction() const {
    return static_cast<TextDirection>(GetField<int32_t>(VT_DIRECTION, 0));
  }
  /// Optional.  Rectangle area to render the text.  If both are zeros,
  /// text will be rendered in a single line.  If height is zero, text will be
  /// rendered in multiple lines if it doesn't fit into a single line.
  /// Since Ion doesn't support text layout, text will always be rendered in
  /// single line in Ion.  Values are measured in meters.
  const lull::Vec2 *bounds() const {
    return GetStruct<const lull::Vec2 *>(VT_BOUNDS);
  }
  /// Optional.  If not None, sets the aabb bounds to the bounds of the text
  /// content.  Otherwise, sets it to bounds.x or bounds.y if non-zero.
  /// Note: This applies to flatui rendering only.
  TextWrapMode wrap_mode() const {
    return static_cast<TextWrapMode>(GetField<int32_t>(VT_WRAP_MODE, 0));
  }
  /// Optional.  The string used as an ellipsis.  Setting this to a nonempty
  /// string enables text truncation. The specified ellipsis will be appended
  /// to the truncated text.
  const flatbuffers::String *ellipsis() const {
    return GetPointer<const flatbuffers::String *>(VT_ELLIPSIS);
  }
  /// Optional.  Glyph edge softness: [0,1] where 0 = hard edges, 1 = opaque @
  /// glyph center.
  float edge_softness() const {
    return GetField<float>(VT_EDGE_SOFTNESS, 0.3f);
  }
  /// Optional.  A float value specifying a scale applied to the kerning value
  /// between glyphs.  This applies to flatui rendering only.
  float kerning_scale() const {
    return GetField<float>(VT_KERNING_SCALE, 1.0f);
  }
  /// Optional.  How HTML tags are processed.
  TextHtmlMode html_mode() const {
    return static_cast<TextHtmlMode>(GetField<int32_t>(VT_HTML_MODE, 0));
  }
  /// Optional.  Each HTML link is created as a separate entity using this
  /// blueprint.
  const flatbuffers::String *link_text_blueprint() const {
    return GetPointer<const flatbuffers::String *>(VT_LINK_TEXT_BLUEPRINT);
  }
  /// Optional.  Each HTML link underline is created as a separate entity
  /// using this blueprint.
  const flatbuffers::String *link_underline_blueprint() const {
    return GetPointer<const flatbuffers::String *>(VT_LINK_UNDERLINE_BLUEPRINT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TEXT) &&
           verifier.Verify(text()) &&
           VerifyOffset(verifier, VT_FONTS) &&
           verifier.Verify(fonts()) &&
           verifier.VerifyVectorOfStrings(fonts()) &&
           VerifyField<float>(verifier, VT_FONT_SIZE) &&
           VerifyField<float>(verifier, VT_LINE_HEIGHT) &&
           VerifyField<float>(verifier, VT_LINE_HEIGHT_SCALE) &&
           VerifyField<int32_t>(verifier, VT_HORIZONTAL_ALIGNMENT) &&
           VerifyField<int32_t>(verifier, VT_VERTICAL_ALIGNMENT) &&
           VerifyField<int32_t>(verifier, VT_DIRECTION) &&
           VerifyField<lull::Vec2>(verifier, VT_BOUNDS) &&
           VerifyField<int32_t>(verifier, VT_WRAP_MODE) &&
           VerifyOffset(verifier, VT_ELLIPSIS) &&
           verifier.Verify(ellipsis()) &&
           VerifyField<float>(verifier, VT_EDGE_SOFTNESS) &&
           VerifyField<float>(verifier, VT_KERNING_SCALE) &&
           VerifyField<int32_t>(verifier, VT_HTML_MODE) &&
           VerifyOffset(verifier, VT_LINK_TEXT_BLUEPRINT) &&
           verifier.Verify(link_text_blueprint()) &&
           VerifyOffset(verifier, VT_LINK_UNDERLINE_BLUEPRINT) &&
           verifier.Verify(link_underline_blueprint()) &&
           verifier.EndTable();
  }
};

struct TextDefBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_text(flatbuffers::Offset<flatbuffers::String> text) {
    fbb_.AddOffset(TextDef::VT_TEXT, text);
  }
  void add_fonts(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> fonts) {
    fbb_.AddOffset(TextDef::VT_FONTS, fonts);
  }
  void add_font_size(float font_size) {
    fbb_.AddElement<float>(TextDef::VT_FONT_SIZE, font_size, 0.0f);
  }
  void add_line_height(float line_height) {
    fbb_.AddElement<float>(TextDef::VT_LINE_HEIGHT, line_height, 0.0f);
  }
  void add_line_height_scale(float line_height_scale) {
    fbb_.AddElement<float>(TextDef::VT_LINE_HEIGHT_SCALE, line_height_scale, 1.2f);
  }
  void add_horizontal_alignment(lull::HorizontalAlignment horizontal_alignment) {
    fbb_.AddElement<int32_t>(TextDef::VT_HORIZONTAL_ALIGNMENT, static_cast<int32_t>(horizontal_alignment), 1);
  }
  void add_vertical_alignment(lull::VerticalAlignment vertical_alignment) {
    fbb_.AddElement<int32_t>(TextDef::VT_VERTICAL_ALIGNMENT, static_cast<int32_t>(vertical_alignment), 2);
  }
  void add_direction(TextDirection direction) {
    fbb_.AddElement<int32_t>(TextDef::VT_DIRECTION, static_cast<int32_t>(direction), 0);
  }
  void add_bounds(const lull::Vec2 *bounds) {
    fbb_.AddStruct(TextDef::VT_BOUNDS, bounds);
  }
  void add_wrap_mode(TextWrapMode wrap_mode) {
    fbb_.AddElement<int32_t>(TextDef::VT_WRAP_MODE, static_cast<int32_t>(wrap_mode), 0);
  }
  void add_ellipsis(flatbuffers::Offset<flatbuffers::String> ellipsis) {
    fbb_.AddOffset(TextDef::VT_ELLIPSIS, ellipsis);
  }
  void add_edge_softness(float edge_softness) {
    fbb_.AddElement<float>(TextDef::VT_EDGE_SOFTNESS, edge_softness, 0.3f);
  }
  void add_kerning_scale(float kerning_scale) {
    fbb_.AddElement<float>(TextDef::VT_KERNING_SCALE, kerning_scale, 1.0f);
  }
  void add_html_mode(TextHtmlMode html_mode) {
    fbb_.AddElement<int32_t>(TextDef::VT_HTML_MODE, static_cast<int32_t>(html_mode), 0);
  }
  void add_link_text_blueprint(flatbuffers::Offset<flatbuffers::String> link_text_blueprint) {
    fbb_.AddOffset(TextDef::VT_LINK_TEXT_BLUEPRINT, link_text_blueprint);
  }
  void add_link_underline_blueprint(flatbuffers::Offset<flatbuffers::String> link_underline_blueprint) {
    fbb_.AddOffset(TextDef::VT_LINK_UNDERLINE_BLUEPRINT, link_underline_blueprint);
  }
  TextDefBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TextDefBuilder &operator=(const TextDefBuilder &);
  flatbuffers::Offset<TextDef> Finish() {
    const auto end = fbb_.EndTable(start_, 16);
    auto o = flatbuffers::Offset<TextDef>(end);
    return o;
  }
};

inline flatbuffers::Offset<TextDef> CreateTextDef(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> text = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> fonts = 0,
    float font_size = 0.0f,
    float line_height = 0.0f,
    float line_height_scale = 1.2f,
    lull::HorizontalAlignment horizontal_alignment = lull::HorizontalAlignment_Center,
    lull::VerticalAlignment vertical_alignment = lull::VerticalAlignment_Baseline,
    TextDirection direction = TextDirection_UseSystemSetting,
    const lull::Vec2 *bounds = 0,
    TextWrapMode wrap_mode = TextWrapMode_None,
    flatbuffers::Offset<flatbuffers::String> ellipsis = 0,
    float edge_softness = 0.3f,
    float kerning_scale = 1.0f,
    TextHtmlMode html_mode = TextHtmlMode_Ignore,
    flatbuffers::Offset<flatbuffers::String> link_text_blueprint = 0,
    flatbuffers::Offset<flatbuffers::String> link_underline_blueprint = 0) {
  TextDefBuilder builder_(_fbb);
  builder_.add_link_underline_blueprint(link_underline_blueprint);
  builder_.add_link_text_blueprint(link_text_blueprint);
  builder_.add_html_mode(html_mode);
  builder_.add_kerning_scale(kerning_scale);
  builder_.add_edge_softness(edge_softness);
  builder_.add_ellipsis(ellipsis);
  builder_.add_wrap_mode(wrap_mode);
  builder_.add_bounds(bounds);
  builder_.add_direction(direction);
  builder_.add_vertical_alignment(vertical_alignment);
  builder_.add_horizontal_alignment(horizontal_alignment);
  builder_.add_line_height_scale(line_height_scale);
  builder_.add_line_height(line_height);
  builder_.add_font_size(font_size);
  builder_.add_fonts(fonts);
  builder_.add_text(text);
  return builder_.Finish();
}

inline flatbuffers::Offset<TextDef> CreateTextDefDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *text = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *fonts = nullptr,
    float font_size = 0.0f,
    float line_height = 0.0f,
    float line_height_scale = 1.2f,
    lull::HorizontalAlignment horizontal_alignment = lull::HorizontalAlignment_Center,
    lull::VerticalAlignment vertical_alignment = lull::VerticalAlignment_Baseline,
    TextDirection direction = TextDirection_UseSystemSetting,
    const lull::Vec2 *bounds = 0,
    TextWrapMode wrap_mode = TextWrapMode_None,
    const char *ellipsis = nullptr,
    float edge_softness = 0.3f,
    float kerning_scale = 1.0f,
    TextHtmlMode html_mode = TextHtmlMode_Ignore,
    const char *link_text_blueprint = nullptr,
    const char *link_underline_blueprint = nullptr) {
  return lull::CreateTextDef(
      _fbb,
      text ? _fbb.CreateString(text) : 0,
      fonts ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*fonts) : 0,
      font_size,
      line_height,
      line_height_scale,
      horizontal_alignment,
      vertical_alignment,
      direction,
      bounds,
      wrap_mode,
      ellipsis ? _fbb.CreateString(ellipsis) : 0,
      edge_softness,
      kerning_scale,
      html_mode,
      link_text_blueprint ? _fbb.CreateString(link_text_blueprint) : 0,
      link_underline_blueprint ? _fbb.CreateString(link_underline_blueprint) : 0);
}

}  // namespace lull

#endif  // FLATBUFFERS_GENERATED_TEXTDEF_LULL_H_
