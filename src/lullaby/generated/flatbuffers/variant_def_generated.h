// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_VARIANTDEF_LULL_H_
#define FLATBUFFERS_GENERATED_VARIANTDEF_LULL_H_

#include "flatbuffers/flatbuffers.h"

#include "common_generated.h"

namespace lull {

struct DataBool;

struct DataInt;

struct DataFloat;

struct DataHashValue;

struct DataString;

struct DataVec2;

struct DataVec3;

struct DataVec4;

struct DataQuat;

struct KeyVariantPairDef;

enum VariantDef {
  VariantDef_NONE = 0,
  VariantDef_DataBool = 1,
  VariantDef_DataInt = 2,
  VariantDef_DataFloat = 3,
  VariantDef_DataString = 4,
  VariantDef_DataHashValue = 5,
  VariantDef_DataVec2 = 6,
  VariantDef_DataVec3 = 7,
  VariantDef_DataVec4 = 8,
  VariantDef_DataQuat = 9,
  VariantDef_MIN = VariantDef_NONE,
  VariantDef_MAX = VariantDef_DataQuat
};

inline const char **EnumNamesVariantDef() {
  static const char *names[] = {
    "NONE",
    "DataBool",
    "DataInt",
    "DataFloat",
    "DataString",
    "DataHashValue",
    "DataVec2",
    "DataVec3",
    "DataVec4",
    "DataQuat",
    nullptr
  };
  return names;
}

inline const char *EnumNameVariantDef(VariantDef e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesVariantDef()[index];
}

template<typename T> struct VariantDefTraits {
  static const VariantDef enum_value = VariantDef_NONE;
};

template<> struct VariantDefTraits<DataBool> {
  static const VariantDef enum_value = VariantDef_DataBool;
};

template<> struct VariantDefTraits<DataInt> {
  static const VariantDef enum_value = VariantDef_DataInt;
};

template<> struct VariantDefTraits<DataFloat> {
  static const VariantDef enum_value = VariantDef_DataFloat;
};

template<> struct VariantDefTraits<DataString> {
  static const VariantDef enum_value = VariantDef_DataString;
};

template<> struct VariantDefTraits<DataHashValue> {
  static const VariantDef enum_value = VariantDef_DataHashValue;
};

template<> struct VariantDefTraits<DataVec2> {
  static const VariantDef enum_value = VariantDef_DataVec2;
};

template<> struct VariantDefTraits<DataVec3> {
  static const VariantDef enum_value = VariantDef_DataVec3;
};

template<> struct VariantDefTraits<DataVec4> {
  static const VariantDef enum_value = VariantDef_DataVec4;
};

template<> struct VariantDefTraits<DataQuat> {
  static const VariantDef enum_value = VariantDef_DataQuat;
};

bool VerifyVariantDef(flatbuffers::Verifier &verifier, const void *obj, VariantDef type);
bool VerifyVariantDefVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct DataBool FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.DataBool";
  }
  enum {
    VT_VALUE = 4
  };
  bool value() const {
    return GetField<uint8_t>(VT_VALUE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct DataBoolBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(bool value) {
    fbb_.AddElement<uint8_t>(DataBool::VT_VALUE, static_cast<uint8_t>(value), 0);
  }
  DataBoolBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DataBoolBuilder &operator=(const DataBoolBuilder &);
  flatbuffers::Offset<DataBool> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<DataBool>(end);
    return o;
  }
};

inline flatbuffers::Offset<DataBool> CreateDataBool(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool value = false) {
  DataBoolBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct DataInt FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.DataInt";
  }
  enum {
    VT_VALUE = 4
  };
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct DataIntBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(DataInt::VT_VALUE, value, 0);
  }
  DataIntBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DataIntBuilder &operator=(const DataIntBuilder &);
  flatbuffers::Offset<DataInt> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<DataInt>(end);
    return o;
  }
};

inline flatbuffers::Offset<DataInt> CreateDataInt(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t value = 0) {
  DataIntBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct DataFloat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.DataFloat";
  }
  enum {
    VT_VALUE = 4
  };
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct DataFloatBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(float value) {
    fbb_.AddElement<float>(DataFloat::VT_VALUE, value, 0.0f);
  }
  DataFloatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DataFloatBuilder &operator=(const DataFloatBuilder &);
  flatbuffers::Offset<DataFloat> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<DataFloat>(end);
    return o;
  }
};

inline flatbuffers::Offset<DataFloat> CreateDataFloat(
    flatbuffers::FlatBufferBuilder &_fbb,
    float value = 0.0f) {
  DataFloatBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct DataHashValue FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.DataHashValue";
  }
  enum {
    VT_VALUE = 4
  };
  const flatbuffers::String *value() const {
    return GetPointer<const flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.Verify(value()) &&
           verifier.EndTable();
  }
};

struct DataHashValueBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::String> value) {
    fbb_.AddOffset(DataHashValue::VT_VALUE, value);
  }
  DataHashValueBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DataHashValueBuilder &operator=(const DataHashValueBuilder &);
  flatbuffers::Offset<DataHashValue> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<DataHashValue>(end);
    return o;
  }
};

inline flatbuffers::Offset<DataHashValue> CreateDataHashValue(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> value = 0) {
  DataHashValueBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<DataHashValue> CreateDataHashValueDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *value = nullptr) {
  return lull::CreateDataHashValue(
      _fbb,
      value ? _fbb.CreateString(value) : 0);
}

struct DataString FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.DataString";
  }
  enum {
    VT_VALUE = 4
  };
  const flatbuffers::String *value() const {
    return GetPointer<const flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.Verify(value()) &&
           verifier.EndTable();
  }
};

struct DataStringBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::String> value) {
    fbb_.AddOffset(DataString::VT_VALUE, value);
  }
  DataStringBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DataStringBuilder &operator=(const DataStringBuilder &);
  flatbuffers::Offset<DataString> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<DataString>(end);
    return o;
  }
};

inline flatbuffers::Offset<DataString> CreateDataString(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> value = 0) {
  DataStringBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<DataString> CreateDataStringDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *value = nullptr) {
  return lull::CreateDataString(
      _fbb,
      value ? _fbb.CreateString(value) : 0);
}

struct DataVec2 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.DataVec2";
  }
  enum {
    VT_VALUE = 4
  };
  const lull::Vec2 *value() const {
    return GetStruct<const lull::Vec2 *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<lull::Vec2>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct DataVec2Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(const lull::Vec2 *value) {
    fbb_.AddStruct(DataVec2::VT_VALUE, value);
  }
  DataVec2Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DataVec2Builder &operator=(const DataVec2Builder &);
  flatbuffers::Offset<DataVec2> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<DataVec2>(end);
    return o;
  }
};

inline flatbuffers::Offset<DataVec2> CreateDataVec2(
    flatbuffers::FlatBufferBuilder &_fbb,
    const lull::Vec2 *value = 0) {
  DataVec2Builder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct DataVec3 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.DataVec3";
  }
  enum {
    VT_VALUE = 4
  };
  const lull::Vec3 *value() const {
    return GetStruct<const lull::Vec3 *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<lull::Vec3>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct DataVec3Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(const lull::Vec3 *value) {
    fbb_.AddStruct(DataVec3::VT_VALUE, value);
  }
  DataVec3Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DataVec3Builder &operator=(const DataVec3Builder &);
  flatbuffers::Offset<DataVec3> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<DataVec3>(end);
    return o;
  }
};

inline flatbuffers::Offset<DataVec3> CreateDataVec3(
    flatbuffers::FlatBufferBuilder &_fbb,
    const lull::Vec3 *value = 0) {
  DataVec3Builder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct DataVec4 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.DataVec4";
  }
  enum {
    VT_VALUE = 4
  };
  const lull::Vec4 *value() const {
    return GetStruct<const lull::Vec4 *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<lull::Vec4>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct DataVec4Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(const lull::Vec4 *value) {
    fbb_.AddStruct(DataVec4::VT_VALUE, value);
  }
  DataVec4Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DataVec4Builder &operator=(const DataVec4Builder &);
  flatbuffers::Offset<DataVec4> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<DataVec4>(end);
    return o;
  }
};

inline flatbuffers::Offset<DataVec4> CreateDataVec4(
    flatbuffers::FlatBufferBuilder &_fbb,
    const lull::Vec4 *value = 0) {
  DataVec4Builder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct DataQuat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.DataQuat";
  }
  enum {
    VT_VALUE = 4
  };
  const lull::Quat *value() const {
    return GetStruct<const lull::Quat *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<lull::Quat>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct DataQuatBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(const lull::Quat *value) {
    fbb_.AddStruct(DataQuat::VT_VALUE, value);
  }
  DataQuatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DataQuatBuilder &operator=(const DataQuatBuilder &);
  flatbuffers::Offset<DataQuat> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<DataQuat>(end);
    return o;
  }
};

inline flatbuffers::Offset<DataQuat> CreateDataQuat(
    flatbuffers::FlatBufferBuilder &_fbb,
    const lull::Quat *value = 0) {
  DataQuatBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct KeyVariantPairDef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "lull.KeyVariantPairDef";
  }
  enum {
    VT_KEY = 4,
    VT_VALUE_TYPE = 6,
    VT_VALUE = 8
  };
  const flatbuffers::String *key() const {
    return GetPointer<const flatbuffers::String *>(VT_KEY);
  }
  VariantDef value_type() const {
    return static_cast<VariantDef>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const DataBool *value_as_DataBool() const {
    return value_type() == VariantDef_DataBool ? static_cast<const DataBool *>(value()) : nullptr;
  }
  const DataInt *value_as_DataInt() const {
    return value_type() == VariantDef_DataInt ? static_cast<const DataInt *>(value()) : nullptr;
  }
  const DataFloat *value_as_DataFloat() const {
    return value_type() == VariantDef_DataFloat ? static_cast<const DataFloat *>(value()) : nullptr;
  }
  const DataString *value_as_DataString() const {
    return value_type() == VariantDef_DataString ? static_cast<const DataString *>(value()) : nullptr;
  }
  const DataHashValue *value_as_DataHashValue() const {
    return value_type() == VariantDef_DataHashValue ? static_cast<const DataHashValue *>(value()) : nullptr;
  }
  const DataVec2 *value_as_DataVec2() const {
    return value_type() == VariantDef_DataVec2 ? static_cast<const DataVec2 *>(value()) : nullptr;
  }
  const DataVec3 *value_as_DataVec3() const {
    return value_type() == VariantDef_DataVec3 ? static_cast<const DataVec3 *>(value()) : nullptr;
  }
  const DataVec4 *value_as_DataVec4() const {
    return value_type() == VariantDef_DataVec4 ? static_cast<const DataVec4 *>(value()) : nullptr;
  }
  const DataQuat *value_as_DataQuat() const {
    return value_type() == VariantDef_DataQuat ? static_cast<const DataQuat *>(value()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.Verify(key()) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifyVariantDef(verifier, value(), value_type()) &&
           verifier.EndTable();
  }
};

template<> inline const DataBool *KeyVariantPairDef::value_as<DataBool>() const {
  return value_as_DataBool();
}

template<> inline const DataInt *KeyVariantPairDef::value_as<DataInt>() const {
  return value_as_DataInt();
}

template<> inline const DataFloat *KeyVariantPairDef::value_as<DataFloat>() const {
  return value_as_DataFloat();
}

template<> inline const DataString *KeyVariantPairDef::value_as<DataString>() const {
  return value_as_DataString();
}

template<> inline const DataHashValue *KeyVariantPairDef::value_as<DataHashValue>() const {
  return value_as_DataHashValue();
}

template<> inline const DataVec2 *KeyVariantPairDef::value_as<DataVec2>() const {
  return value_as_DataVec2();
}

template<> inline const DataVec3 *KeyVariantPairDef::value_as<DataVec3>() const {
  return value_as_DataVec3();
}

template<> inline const DataVec4 *KeyVariantPairDef::value_as<DataVec4>() const {
  return value_as_DataVec4();
}

template<> inline const DataQuat *KeyVariantPairDef::value_as<DataQuat>() const {
  return value_as_DataQuat();
}

struct KeyVariantPairDefBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(flatbuffers::Offset<flatbuffers::String> key) {
    fbb_.AddOffset(KeyVariantPairDef::VT_KEY, key);
  }
  void add_value_type(VariantDef value_type) {
    fbb_.AddElement<uint8_t>(KeyVariantPairDef::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(flatbuffers::Offset<void> value) {
    fbb_.AddOffset(KeyVariantPairDef::VT_VALUE, value);
  }
  KeyVariantPairDefBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  KeyVariantPairDefBuilder &operator=(const KeyVariantPairDefBuilder &);
  flatbuffers::Offset<KeyVariantPairDef> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<KeyVariantPairDef>(end);
    return o;
  }
};

inline flatbuffers::Offset<KeyVariantPairDef> CreateKeyVariantPairDef(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> key = 0,
    VariantDef value_type = VariantDef_NONE,
    flatbuffers::Offset<void> value = 0) {
  KeyVariantPairDefBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<KeyVariantPairDef> CreateKeyVariantPairDefDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    VariantDef value_type = VariantDef_NONE,
    flatbuffers::Offset<void> value = 0) {
  return lull::CreateKeyVariantPairDef(
      _fbb,
      key ? _fbb.CreateString(key) : 0,
      value_type,
      value);
}

inline bool VerifyVariantDef(flatbuffers::Verifier &verifier, const void *obj, VariantDef type) {
  switch (type) {
    case VariantDef_NONE: {
      return true;
    }
    case VariantDef_DataBool: {
      auto ptr = reinterpret_cast<const DataBool *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VariantDef_DataInt: {
      auto ptr = reinterpret_cast<const DataInt *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VariantDef_DataFloat: {
      auto ptr = reinterpret_cast<const DataFloat *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VariantDef_DataString: {
      auto ptr = reinterpret_cast<const DataString *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VariantDef_DataHashValue: {
      auto ptr = reinterpret_cast<const DataHashValue *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VariantDef_DataVec2: {
      auto ptr = reinterpret_cast<const DataVec2 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VariantDef_DataVec3: {
      auto ptr = reinterpret_cast<const DataVec3 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VariantDef_DataVec4: {
      auto ptr = reinterpret_cast<const DataVec4 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VariantDef_DataQuat: {
      auto ptr = reinterpret_cast<const DataQuat *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyVariantDefVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyVariantDef(
        verifier,  values->Get(i), types->GetEnum<VariantDef>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace lull

#endif  // FLATBUFFERS_GENERATED_VARIANTDEF_LULL_H_
