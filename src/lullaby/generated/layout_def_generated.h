// Autogenerated code.  Do not edit.
#ifndef _SRC_LULLABY_GENERATED_LAYOUT_DEF_GENERATED_H_
#define _SRC_LULLABY_GENERATED_LAYOUT_DEF_GENERATED_H_

#include <type_traits>
#include <memory>
#include "flatbuffers/layout_def_generated.h"
#include "lullaby/base/common_types.h"
#include "lullaby/base/typeid.h"
#include "lullaby/util/color.h"
#include "lullaby/util/math.h"
#include "lullaby/util/optional.h"
#include "common_generated.h"

namespace lull {
class LayoutDefT;
class LayoutElementDefT;
class RadialLayoutDefT;
class LayoutDefT {
 public:
  using FlatBufferType = LayoutDef;

  mathfu::vec2 canvas_size = {0.f, 0.f};
  bool shrink_to_fit = 0;
  mathfu::vec2 spacing = {0.f, 0.f};
  lull::LayoutFillOrder fill_order = lull::LayoutFillOrder_RightDown;
  lull::LayoutHorizontalAlignment horizontal_alignment = lull::LayoutHorizontalAlignment_Left;
  lull::LayoutVerticalAlignment vertical_alignment = lull::LayoutVerticalAlignment_Top;
  lull::LayoutVerticalAlignment row_alignment = lull::LayoutVerticalAlignment_Top;
  int32_t elements_per_wrap = 0;
  int32_t max_elements = 0;
  std::string empty_blueprint;
  lull::LayoutHorizontalAlignment column_alignment = lull::LayoutHorizontalAlignment_Left;

  template <typename Archive>
  void SerializeFlatbuffer(Archive archive);
};

class LayoutElementDefT {
 public:
  using FlatBufferType = LayoutElementDef;

  float horizontal_weight = 0.0f;
  float vertical_weight = 0.0f;

  template <typename Archive>
  void SerializeFlatbuffer(Archive archive);
};

class RadialLayoutDefT {
 public:
  using FlatBufferType = RadialLayoutDef;

  float degrees_per_element = 0.0f;
  mathfu::vec3 major_axis = {0.f, 0.f, 0.f};
  mathfu::vec3 minor_axis = {0.f, 0.f, 0.f};
  int32_t max_elements = 0;
  std::string empty_blueprint;

  template <typename Archive>
  void SerializeFlatbuffer(Archive archive);
};

template <typename Archive>
void LayoutDefT::SerializeFlatbuffer(Archive archive) {
  archive.String(&empty_blueprint, 22);
  archive.NativeStruct(&canvas_size, 4);
  archive.Scalar(&shrink_to_fit, 6, 0);
  archive.NativeStruct(&spacing, 8);
  int32_t _fill_order = static_cast<int32_t>(fill_order);
  archive.Scalar(&_fill_order, 10, lull::LayoutFillOrder_RightDown);
  fill_order = static_cast<lull::LayoutFillOrder>(_fill_order);
  int32_t _horizontal_alignment = static_cast<int32_t>(horizontal_alignment);
  archive.Scalar(&_horizontal_alignment, 12, lull::LayoutHorizontalAlignment_Left);
  horizontal_alignment = static_cast<lull::LayoutHorizontalAlignment>(_horizontal_alignment);
  int32_t _vertical_alignment = static_cast<int32_t>(vertical_alignment);
  archive.Scalar(&_vertical_alignment, 14, lull::LayoutVerticalAlignment_Top);
  vertical_alignment = static_cast<lull::LayoutVerticalAlignment>(_vertical_alignment);
  int32_t _row_alignment = static_cast<int32_t>(row_alignment);
  archive.Scalar(&_row_alignment, 16, lull::LayoutVerticalAlignment_Top);
  row_alignment = static_cast<lull::LayoutVerticalAlignment>(_row_alignment);
  archive.Scalar(&elements_per_wrap, 18, 0);
  archive.Scalar(&max_elements, 20, 0);
  int32_t _column_alignment = static_cast<int32_t>(column_alignment);
  archive.Scalar(&_column_alignment, 24, lull::LayoutHorizontalAlignment_Left);
  column_alignment = static_cast<lull::LayoutHorizontalAlignment>(_column_alignment);
}

template <typename Archive>
void LayoutElementDefT::SerializeFlatbuffer(Archive archive) {
  archive.Scalar(&horizontal_weight, 4, 0.0f);
  archive.Scalar(&vertical_weight, 6, 0.0f);
}

template <typename Archive>
void RadialLayoutDefT::SerializeFlatbuffer(Archive archive) {
  archive.String(&empty_blueprint, 12);
  archive.Scalar(&degrees_per_element, 4, 0.0f);
  archive.NativeStruct(&major_axis, 6);
  archive.NativeStruct(&minor_axis, 8);
  archive.Scalar(&max_elements, 10, 0);
}

}  // namespace lull

LULLABY_SETUP_TYPEID(lull::LayoutDefT);
LULLABY_SETUP_TYPEID(lull::LayoutElementDefT);
LULLABY_SETUP_TYPEID(lull::RadialLayoutDefT);

#endif  // _SRC_LULLABY_GENERATED_LAYOUT_DEF_GENERATED_H_

