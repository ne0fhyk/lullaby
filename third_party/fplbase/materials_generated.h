/*
Copyright 2017 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS-IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MATERIALS_MATDEF_H_
#define FLATBUFFERS_GENERATED_MATERIALS_MATDEF_H_

#include "flatbuffers/flatbuffers.h"

#include "common_generated.h"

namespace matdef {

struct Material;

enum BlendMode {
  BlendMode_OFF = 0,
  BlendMode_TEST = 1,
  BlendMode_ALPHA = 2,
  BlendMode_ADD = 3,
  BlendMode_ADDALPHA = 4,
  BlendMode_MULTIPLY = 5,
  BlendMode_PREMULTIPLIEDALPHA = 6,
  BlendMode_MIN = BlendMode_OFF,
  BlendMode_MAX = BlendMode_PREMULTIPLIEDALPHA
};

inline BlendMode (&EnumValuesBlendMode())[7] {
  static BlendMode values[] = {
    BlendMode_OFF,
    BlendMode_TEST,
    BlendMode_ALPHA,
    BlendMode_ADD,
    BlendMode_ADDALPHA,
    BlendMode_MULTIPLY,
    BlendMode_PREMULTIPLIEDALPHA
  };
  return values;
}

inline const char **EnumNamesBlendMode() {
  static const char *names[] = {
    "OFF",
    "TEST",
    "ALPHA",
    "ADD",
    "ADDALPHA",
    "MULTIPLY",
    "PREMULTIPLIEDALPHA",
    nullptr
  };
  return names;
}

inline const char *EnumNameBlendMode(BlendMode e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesBlendMode()[index];
}

enum TextureFormat {
  TextureFormat_AUTO = 0,
  TextureFormat_F_8888 = 1,
  TextureFormat_F_888 = 2,
  TextureFormat_F_5551 = 3,
  TextureFormat_F_565 = 4,
  TextureFormat_F_8 = 5,
  TextureFormat_ASTC = 6,
  TextureFormat_PKM = 7,
  TextureFormat_KTX = 8,
  TextureFormat_NATIVE = 9,
  TextureFormat_F_88 = 10,
  TextureFormat_MIN = TextureFormat_AUTO,
  TextureFormat_MAX = TextureFormat_F_88
};

inline TextureFormat (&EnumValuesTextureFormat())[11] {
  static TextureFormat values[] = {
    TextureFormat_AUTO,
    TextureFormat_F_8888,
    TextureFormat_F_888,
    TextureFormat_F_5551,
    TextureFormat_F_565,
    TextureFormat_F_8,
    TextureFormat_ASTC,
    TextureFormat_PKM,
    TextureFormat_KTX,
    TextureFormat_NATIVE,
    TextureFormat_F_88
  };
  return values;
}

inline const char **EnumNamesTextureFormat() {
  static const char *names[] = {
    "AUTO",
    "F_8888",
    "F_888",
    "F_5551",
    "F_565",
    "F_8",
    "ASTC",
    "PKM",
    "KTX",
    "NATIVE",
    "F_88",
    nullptr
  };
  return names;
}

inline const char *EnumNameTextureFormat(TextureFormat e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesTextureFormat()[index];
}

enum TextureWrap {
  TextureWrap_REPEAT = 0,
  TextureWrap_CLAMP = 1,
  TextureWrap_MIN = TextureWrap_REPEAT,
  TextureWrap_MAX = TextureWrap_CLAMP
};

inline TextureWrap (&EnumValuesTextureWrap())[2] {
  static TextureWrap values[] = {
    TextureWrap_REPEAT,
    TextureWrap_CLAMP
  };
  return values;
}

inline const char **EnumNamesTextureWrap() {
  static const char *names[] = {
    "REPEAT",
    "CLAMP",
    nullptr
  };
  return names;
}

inline const char *EnumNameTextureWrap(TextureWrap e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesTextureWrap()[index];
}

struct Material FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TEXTURE_FILENAMES = 4,
    VT_BLENDMODE = 6,
    VT_DESIRED_FORMAT = 8,
    VT_ORIGINAL_SIZE = 10,
    VT_MIPMAPS = 12,
    VT_IS_CUBEMAP = 14,
    VT_WRAPMODE = 16
  };
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *texture_filenames() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_TEXTURE_FILENAMES);
  }
  BlendMode blendmode() const {
    return static_cast<BlendMode>(GetField<uint8_t>(VT_BLENDMODE, 0));
  }
  const flatbuffers::Vector<uint8_t> *desired_format() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DESIRED_FORMAT);
  }
  const flatbuffers::Vector<const fplbase::Vec2i *> *original_size() const {
    return GetPointer<const flatbuffers::Vector<const fplbase::Vec2i *> *>(VT_ORIGINAL_SIZE);
  }
  bool mipmaps() const {
    return GetField<uint8_t>(VT_MIPMAPS, 1) != 0;
  }
  const flatbuffers::Vector<uint8_t> *is_cubemap() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_IS_CUBEMAP);
  }
  TextureWrap wrapmode() const {
    return static_cast<TextureWrap>(GetField<uint8_t>(VT_WRAPMODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TEXTURE_FILENAMES) &&
           verifier.Verify(texture_filenames()) &&
           verifier.VerifyVectorOfStrings(texture_filenames()) &&
           VerifyField<uint8_t>(verifier, VT_BLENDMODE) &&
           VerifyOffset(verifier, VT_DESIRED_FORMAT) &&
           verifier.Verify(desired_format()) &&
           VerifyOffset(verifier, VT_ORIGINAL_SIZE) &&
           verifier.Verify(original_size()) &&
           VerifyField<uint8_t>(verifier, VT_MIPMAPS) &&
           VerifyOffset(verifier, VT_IS_CUBEMAP) &&
           verifier.Verify(is_cubemap()) &&
           VerifyField<uint8_t>(verifier, VT_WRAPMODE) &&
           verifier.EndTable();
  }
};

struct MaterialBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_texture_filenames(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> texture_filenames) {
    fbb_.AddOffset(Material::VT_TEXTURE_FILENAMES, texture_filenames);
  }
  void add_blendmode(BlendMode blendmode) {
    fbb_.AddElement<uint8_t>(Material::VT_BLENDMODE, static_cast<uint8_t>(blendmode), 0);
  }
  void add_desired_format(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> desired_format) {
    fbb_.AddOffset(Material::VT_DESIRED_FORMAT, desired_format);
  }
  void add_original_size(flatbuffers::Offset<flatbuffers::Vector<const fplbase::Vec2i *>> original_size) {
    fbb_.AddOffset(Material::VT_ORIGINAL_SIZE, original_size);
  }
  void add_mipmaps(bool mipmaps) {
    fbb_.AddElement<uint8_t>(Material::VT_MIPMAPS, static_cast<uint8_t>(mipmaps), 1);
  }
  void add_is_cubemap(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> is_cubemap) {
    fbb_.AddOffset(Material::VT_IS_CUBEMAP, is_cubemap);
  }
  void add_wrapmode(TextureWrap wrapmode) {
    fbb_.AddElement<uint8_t>(Material::VT_WRAPMODE, static_cast<uint8_t>(wrapmode), 0);
  }
  MaterialBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MaterialBuilder &operator=(const MaterialBuilder &);
  flatbuffers::Offset<Material> Finish() {
    const auto end = fbb_.EndTable(start_, 7);
    auto o = flatbuffers::Offset<Material>(end);
    return o;
  }
};

inline flatbuffers::Offset<Material> CreateMaterial(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> texture_filenames = 0,
    BlendMode blendmode = BlendMode_OFF,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> desired_format = 0,
    flatbuffers::Offset<flatbuffers::Vector<const fplbase::Vec2i *>> original_size = 0,
    bool mipmaps = true,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> is_cubemap = 0,
    TextureWrap wrapmode = TextureWrap_REPEAT) {
  MaterialBuilder builder_(_fbb);
  builder_.add_is_cubemap(is_cubemap);
  builder_.add_original_size(original_size);
  builder_.add_desired_format(desired_format);
  builder_.add_texture_filenames(texture_filenames);
  builder_.add_wrapmode(wrapmode);
  builder_.add_mipmaps(mipmaps);
  builder_.add_blendmode(blendmode);
  return builder_.Finish();
}

inline flatbuffers::Offset<Material> CreateMaterialDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *texture_filenames = nullptr,
    BlendMode blendmode = BlendMode_OFF,
    const std::vector<uint8_t> *desired_format = nullptr,
    const std::vector<const fplbase::Vec2i *> *original_size = nullptr,
    bool mipmaps = true,
    const std::vector<uint8_t> *is_cubemap = nullptr,
    TextureWrap wrapmode = TextureWrap_REPEAT) {
  return matdef::CreateMaterial(
      _fbb,
      texture_filenames ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*texture_filenames) : 0,
      blendmode,
      desired_format ? _fbb.CreateVector<uint8_t>(*desired_format) : 0,
      original_size ? _fbb.CreateVector<const fplbase::Vec2i *>(*original_size) : 0,
      mipmaps,
      is_cubemap ? _fbb.CreateVector<uint8_t>(*is_cubemap) : 0,
      wrapmode);
}

inline const matdef::Material *GetMaterial(const void *buf) {
  return flatbuffers::GetRoot<matdef::Material>(buf);
}

inline const char *MaterialIdentifier() {
  return "FMAT";
}

inline bool MaterialBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, MaterialIdentifier());
}

inline bool VerifyMaterialBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<matdef::Material>(MaterialIdentifier());
}

inline const char *MaterialExtension() {
  return "fplmat";
}

inline void FinishMaterialBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<matdef::Material> root) {
  fbb.Finish(root, MaterialIdentifier());
}

}  // namespace matdef

#endif  // FLATBUFFERS_GENERATED_MATERIALS_MATDEF_H_