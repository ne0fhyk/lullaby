/*
Copyright 2017 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS-IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_COMPACTSPLINE_MOTIVE_H_
#define FLATBUFFERS_GENERATED_COMPACTSPLINE_MOTIVE_H_

#include "flatbuffers/flatbuffers.h"

namespace motive {

struct CompactSplineNodeFb;

struct CompactSplineFloatNodeFb;

struct CompactSplineFb;

struct CompactSplineFloatFb;

MANUALLY_ALIGNED_STRUCT(2) CompactSplineNodeFb FLATBUFFERS_FINAL_CLASS {
 private:
  uint16_t x_;
  uint16_t y_;
  int16_t angle_;

 public:
  CompactSplineNodeFb() {
    memset(this, 0, sizeof(CompactSplineNodeFb));
  }
  CompactSplineNodeFb(const CompactSplineNodeFb &_o) {
    memcpy(this, &_o, sizeof(CompactSplineNodeFb));
  }
  CompactSplineNodeFb(uint16_t _x, uint16_t _y, int16_t _angle)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        angle_(flatbuffers::EndianScalar(_angle)) {
  }
  uint16_t x() const {
    return flatbuffers::EndianScalar(x_);
  }
  uint16_t y() const {
    return flatbuffers::EndianScalar(y_);
  }
  int16_t angle() const {
    return flatbuffers::EndianScalar(angle_);
  }
};
STRUCT_END(CompactSplineNodeFb, 6);

MANUALLY_ALIGNED_STRUCT(4) CompactSplineFloatNodeFb FLATBUFFERS_FINAL_CLASS {
 private:
  float value_;
  float time_;
  float derivative_;

 public:
  CompactSplineFloatNodeFb() {
    memset(this, 0, sizeof(CompactSplineFloatNodeFb));
  }
  CompactSplineFloatNodeFb(const CompactSplineFloatNodeFb &_o) {
    memcpy(this, &_o, sizeof(CompactSplineFloatNodeFb));
  }
  CompactSplineFloatNodeFb(float _value, float _time, float _derivative)
      : value_(flatbuffers::EndianScalar(_value)),
        time_(flatbuffers::EndianScalar(_time)),
        derivative_(flatbuffers::EndianScalar(_derivative)) {
  }
  float value() const {
    return flatbuffers::EndianScalar(value_);
  }
  float time() const {
    return flatbuffers::EndianScalar(time_);
  }
  float derivative() const {
    return flatbuffers::EndianScalar(derivative_);
  }
};
STRUCT_END(CompactSplineFloatNodeFb, 12);

struct CompactSplineFb FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_Y_RANGE_START = 4,
    VT_Y_RANGE_END = 6,
    VT_X_GRANULARITY = 8,
    VT_NODES = 10
  };
  float y_range_start() const {
    return GetField<float>(VT_Y_RANGE_START, 0.0f);
  }
  float y_range_end() const {
    return GetField<float>(VT_Y_RANGE_END, 0.0f);
  }
  float x_granularity() const {
    return GetField<float>(VT_X_GRANULARITY, 0.0f);
  }
  const flatbuffers::Vector<const CompactSplineNodeFb *> *nodes() const {
    return GetPointer<const flatbuffers::Vector<const CompactSplineNodeFb *> *>(VT_NODES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_Y_RANGE_START) &&
           VerifyField<float>(verifier, VT_Y_RANGE_END) &&
           VerifyField<float>(verifier, VT_X_GRANULARITY) &&
           VerifyOffset(verifier, VT_NODES) &&
           verifier.Verify(nodes()) &&
           verifier.EndTable();
  }
};

struct CompactSplineFbBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_y_range_start(float y_range_start) {
    fbb_.AddElement<float>(CompactSplineFb::VT_Y_RANGE_START, y_range_start, 0.0f);
  }
  void add_y_range_end(float y_range_end) {
    fbb_.AddElement<float>(CompactSplineFb::VT_Y_RANGE_END, y_range_end, 0.0f);
  }
  void add_x_granularity(float x_granularity) {
    fbb_.AddElement<float>(CompactSplineFb::VT_X_GRANULARITY, x_granularity, 0.0f);
  }
  void add_nodes(flatbuffers::Offset<flatbuffers::Vector<const CompactSplineNodeFb *>> nodes) {
    fbb_.AddOffset(CompactSplineFb::VT_NODES, nodes);
  }
  CompactSplineFbBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CompactSplineFbBuilder &operator=(const CompactSplineFbBuilder &);
  flatbuffers::Offset<CompactSplineFb> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<CompactSplineFb>(end);
    return o;
  }
};

inline flatbuffers::Offset<CompactSplineFb> CreateCompactSplineFb(
    flatbuffers::FlatBufferBuilder &_fbb,
    float y_range_start = 0.0f,
    float y_range_end = 0.0f,
    float x_granularity = 0.0f,
    flatbuffers::Offset<flatbuffers::Vector<const CompactSplineNodeFb *>> nodes = 0) {
  CompactSplineFbBuilder builder_(_fbb);
  builder_.add_nodes(nodes);
  builder_.add_x_granularity(x_granularity);
  builder_.add_y_range_end(y_range_end);
  builder_.add_y_range_start(y_range_start);
  return builder_.Finish();
}

inline flatbuffers::Offset<CompactSplineFb> CreateCompactSplineFbDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    float y_range_start = 0.0f,
    float y_range_end = 0.0f,
    float x_granularity = 0.0f,
    const std::vector<const CompactSplineNodeFb *> *nodes = nullptr) {
  return motive::CreateCompactSplineFb(
      _fbb,
      y_range_start,
      y_range_end,
      x_granularity,
      nodes ? _fbb.CreateVector<const CompactSplineNodeFb *>(*nodes) : 0);
}

struct CompactSplineFloatFb FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MIN_VALUE = 4,
    VT_MAX_VALUE = 6,
    VT_NODES = 8
  };
  float min_value() const {
    return GetField<float>(VT_MIN_VALUE, 0.0f);
  }
  float max_value() const {
    return GetField<float>(VT_MAX_VALUE, 0.0f);
  }
  const flatbuffers::Vector<const CompactSplineFloatNodeFb *> *nodes() const {
    return GetPointer<const flatbuffers::Vector<const CompactSplineFloatNodeFb *> *>(VT_NODES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_MIN_VALUE) &&
           VerifyField<float>(verifier, VT_MAX_VALUE) &&
           VerifyOffset(verifier, VT_NODES) &&
           verifier.Verify(nodes()) &&
           verifier.EndTable();
  }
};

struct CompactSplineFloatFbBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_min_value(float min_value) {
    fbb_.AddElement<float>(CompactSplineFloatFb::VT_MIN_VALUE, min_value, 0.0f);
  }
  void add_max_value(float max_value) {
    fbb_.AddElement<float>(CompactSplineFloatFb::VT_MAX_VALUE, max_value, 0.0f);
  }
  void add_nodes(flatbuffers::Offset<flatbuffers::Vector<const CompactSplineFloatNodeFb *>> nodes) {
    fbb_.AddOffset(CompactSplineFloatFb::VT_NODES, nodes);
  }
  CompactSplineFloatFbBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CompactSplineFloatFbBuilder &operator=(const CompactSplineFloatFbBuilder &);
  flatbuffers::Offset<CompactSplineFloatFb> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<CompactSplineFloatFb>(end);
    return o;
  }
};

inline flatbuffers::Offset<CompactSplineFloatFb> CreateCompactSplineFloatFb(
    flatbuffers::FlatBufferBuilder &_fbb,
    float min_value = 0.0f,
    float max_value = 0.0f,
    flatbuffers::Offset<flatbuffers::Vector<const CompactSplineFloatNodeFb *>> nodes = 0) {
  CompactSplineFloatFbBuilder builder_(_fbb);
  builder_.add_nodes(nodes);
  builder_.add_max_value(max_value);
  builder_.add_min_value(min_value);
  return builder_.Finish();
}

inline flatbuffers::Offset<CompactSplineFloatFb> CreateCompactSplineFloatFbDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    float min_value = 0.0f,
    float max_value = 0.0f,
    const std::vector<const CompactSplineFloatNodeFb *> *nodes = nullptr) {
  return motive::CreateCompactSplineFloatFb(
      _fbb,
      min_value,
      max_value,
      nodes ? _fbb.CreateVector<const CompactSplineFloatNodeFb *>(*nodes) : 0);
}

}  // namespace motive

#endif  // FLATBUFFERS_GENERATED_COMPACTSPLINE_MOTIVE_H_
