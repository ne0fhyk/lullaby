/*
Copyright 2017 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS-IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MOTIVE_MOTIVE_H_
#define FLATBUFFERS_GENERATED_MOTIVE_MOTIVE_H_

#include "flatbuffers/flatbuffers.h"

namespace motive {

struct Settled1fParameters;

struct ModularParameters;

struct OvershootParameters;

struct SplineParameters;

struct TwitchParameters;

struct Settled1fParameters FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MAX_DIFFERENCE = 4,
    VT_MAX_VELOCITY = 6
  };
  float max_difference() const {
    return GetField<float>(VT_MAX_DIFFERENCE, 0.0f);
  }
  float max_velocity() const {
    return GetField<float>(VT_MAX_VELOCITY, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_MAX_DIFFERENCE) &&
           VerifyField<float>(verifier, VT_MAX_VELOCITY) &&
           verifier.EndTable();
  }
};

struct Settled1fParametersBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_max_difference(float max_difference) {
    fbb_.AddElement<float>(Settled1fParameters::VT_MAX_DIFFERENCE, max_difference, 0.0f);
  }
  void add_max_velocity(float max_velocity) {
    fbb_.AddElement<float>(Settled1fParameters::VT_MAX_VELOCITY, max_velocity, 0.0f);
  }
  Settled1fParametersBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Settled1fParametersBuilder &operator=(const Settled1fParametersBuilder &);
  flatbuffers::Offset<Settled1fParameters> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Settled1fParameters>(end);
    return o;
  }
};

inline flatbuffers::Offset<Settled1fParameters> CreateSettled1fParameters(
    flatbuffers::FlatBufferBuilder &_fbb,
    float max_difference = 0.0f,
    float max_velocity = 0.0f) {
  Settled1fParametersBuilder builder_(_fbb);
  builder_.add_max_velocity(max_velocity);
  builder_.add_max_difference(max_difference);
  return builder_.Finish();
}

struct ModularParameters FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MODULAR = 4,
    VT_MIN = 6,
    VT_MAX = 8
  };
  bool modular() const {
    return GetField<uint8_t>(VT_MODULAR, 0) != 0;
  }
  float min() const {
    return GetField<float>(VT_MIN, 0.0f);
  }
  float max() const {
    return GetField<float>(VT_MAX, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MODULAR) &&
           VerifyField<float>(verifier, VT_MIN) &&
           VerifyField<float>(verifier, VT_MAX) &&
           verifier.EndTable();
  }
};

struct ModularParametersBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_modular(bool modular) {
    fbb_.AddElement<uint8_t>(ModularParameters::VT_MODULAR, static_cast<uint8_t>(modular), 0);
  }
  void add_min(float min) {
    fbb_.AddElement<float>(ModularParameters::VT_MIN, min, 0.0f);
  }
  void add_max(float max) {
    fbb_.AddElement<float>(ModularParameters::VT_MAX, max, 0.0f);
  }
  ModularParametersBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ModularParametersBuilder &operator=(const ModularParametersBuilder &);
  flatbuffers::Offset<ModularParameters> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<ModularParameters>(end);
    return o;
  }
};

inline flatbuffers::Offset<ModularParameters> CreateModularParameters(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool modular = false,
    float min = 0.0f,
    float max = 0.0f) {
  ModularParametersBuilder builder_(_fbb);
  builder_.add_max(max);
  builder_.add_min(min);
  builder_.add_modular(modular);
  return builder_.Finish();
}

struct OvershootParameters FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_BASE = 4,
    VT_MAX_VELOCITY = 6,
    VT_MAX_DELTA = 8,
    VT_AT_TARGET = 10,
    VT_ACCELERATION_PER_DIFFERENCE = 12,
    VT_WRONG_DIRECTION_ACCELERATION_MULTIPLIER = 14,
    VT_MAX_DELTA_TIME = 16
  };
  const ModularParameters *base() const {
    return GetPointer<const ModularParameters *>(VT_BASE);
  }
  float max_velocity() const {
    return GetField<float>(VT_MAX_VELOCITY, 0.0f);
  }
  float max_delta() const {
    return GetField<float>(VT_MAX_DELTA, 0.0f);
  }
  const Settled1fParameters *at_target() const {
    return GetPointer<const Settled1fParameters *>(VT_AT_TARGET);
  }
  float acceleration_per_difference() const {
    return GetField<float>(VT_ACCELERATION_PER_DIFFERENCE, 0.0f);
  }
  float wrong_direction_acceleration_multiplier() const {
    return GetField<float>(VT_WRONG_DIRECTION_ACCELERATION_MULTIPLIER, 0.0f);
  }
  int16_t max_delta_time() const {
    return GetField<int16_t>(VT_MAX_DELTA_TIME, 32767);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BASE) &&
           verifier.VerifyTable(base()) &&
           VerifyField<float>(verifier, VT_MAX_VELOCITY) &&
           VerifyField<float>(verifier, VT_MAX_DELTA) &&
           VerifyOffset(verifier, VT_AT_TARGET) &&
           verifier.VerifyTable(at_target()) &&
           VerifyField<float>(verifier, VT_ACCELERATION_PER_DIFFERENCE) &&
           VerifyField<float>(verifier, VT_WRONG_DIRECTION_ACCELERATION_MULTIPLIER) &&
           VerifyField<int16_t>(verifier, VT_MAX_DELTA_TIME) &&
           verifier.EndTable();
  }
};

struct OvershootParametersBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_base(flatbuffers::Offset<ModularParameters> base) {
    fbb_.AddOffset(OvershootParameters::VT_BASE, base);
  }
  void add_max_velocity(float max_velocity) {
    fbb_.AddElement<float>(OvershootParameters::VT_MAX_VELOCITY, max_velocity, 0.0f);
  }
  void add_max_delta(float max_delta) {
    fbb_.AddElement<float>(OvershootParameters::VT_MAX_DELTA, max_delta, 0.0f);
  }
  void add_at_target(flatbuffers::Offset<Settled1fParameters> at_target) {
    fbb_.AddOffset(OvershootParameters::VT_AT_TARGET, at_target);
  }
  void add_acceleration_per_difference(float acceleration_per_difference) {
    fbb_.AddElement<float>(OvershootParameters::VT_ACCELERATION_PER_DIFFERENCE, acceleration_per_difference, 0.0f);
  }
  void add_wrong_direction_acceleration_multiplier(float wrong_direction_acceleration_multiplier) {
    fbb_.AddElement<float>(OvershootParameters::VT_WRONG_DIRECTION_ACCELERATION_MULTIPLIER, wrong_direction_acceleration_multiplier, 0.0f);
  }
  void add_max_delta_time(int16_t max_delta_time) {
    fbb_.AddElement<int16_t>(OvershootParameters::VT_MAX_DELTA_TIME, max_delta_time, 32767);
  }
  OvershootParametersBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OvershootParametersBuilder &operator=(const OvershootParametersBuilder &);
  flatbuffers::Offset<OvershootParameters> Finish() {
    const auto end = fbb_.EndTable(start_, 7);
    auto o = flatbuffers::Offset<OvershootParameters>(end);
    return o;
  }
};

inline flatbuffers::Offset<OvershootParameters> CreateOvershootParameters(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<ModularParameters> base = 0,
    float max_velocity = 0.0f,
    float max_delta = 0.0f,
    flatbuffers::Offset<Settled1fParameters> at_target = 0,
    float acceleration_per_difference = 0.0f,
    float wrong_direction_acceleration_multiplier = 0.0f,
    int16_t max_delta_time = 32767) {
  OvershootParametersBuilder builder_(_fbb);
  builder_.add_wrong_direction_acceleration_multiplier(wrong_direction_acceleration_multiplier);
  builder_.add_acceleration_per_difference(acceleration_per_difference);
  builder_.add_at_target(at_target);
  builder_.add_max_delta(max_delta);
  builder_.add_max_velocity(max_velocity);
  builder_.add_base(base);
  builder_.add_max_delta_time(max_delta_time);
  return builder_.Finish();
}

struct SplineParameters FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_BASE = 4
  };
  const ModularParameters *base() const {
    return GetPointer<const ModularParameters *>(VT_BASE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BASE) &&
           verifier.VerifyTable(base()) &&
           verifier.EndTable();
  }
};

struct SplineParametersBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_base(flatbuffers::Offset<ModularParameters> base) {
    fbb_.AddOffset(SplineParameters::VT_BASE, base);
  }
  SplineParametersBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SplineParametersBuilder &operator=(const SplineParametersBuilder &);
  flatbuffers::Offset<SplineParameters> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<SplineParameters>(end);
    return o;
  }
};

inline flatbuffers::Offset<SplineParameters> CreateSplineParameters(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<ModularParameters> base = 0) {
  SplineParametersBuilder builder_(_fbb);
  builder_.add_base(base);
  return builder_.Finish();
}

struct TwitchParameters FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SETTLED = 4
  };
  const Settled1fParameters *settled() const {
    return GetPointer<const Settled1fParameters *>(VT_SETTLED);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SETTLED) &&
           verifier.VerifyTable(settled()) &&
           verifier.EndTable();
  }
};

struct TwitchParametersBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_settled(flatbuffers::Offset<Settled1fParameters> settled) {
    fbb_.AddOffset(TwitchParameters::VT_SETTLED, settled);
  }
  TwitchParametersBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TwitchParametersBuilder &operator=(const TwitchParametersBuilder &);
  flatbuffers::Offset<TwitchParameters> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<TwitchParameters>(end);
    return o;
  }
};

inline flatbuffers::Offset<TwitchParameters> CreateTwitchParameters(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Settled1fParameters> settled = 0) {
  TwitchParametersBuilder builder_(_fbb);
  builder_.add_settled(settled);
  return builder_.Finish();
}

}  // namespace motive

#endif  // FLATBUFFERS_GENERATED_MOTIVE_MOTIVE_H_
